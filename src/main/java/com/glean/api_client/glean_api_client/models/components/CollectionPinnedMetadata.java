/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class CollectionPinnedMetadata {

    /**
     * List of targets this Collection is pinned to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("existingPins")
    private Optional<? extends List<CollectionPinTarget>> existingPins;

    /**
     * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("eligiblePins")
    private Optional<? extends List<CollectionPinMetadata>> eligiblePins;

    @JsonCreator
    public CollectionPinnedMetadata(
            @JsonProperty("existingPins") Optional<? extends List<CollectionPinTarget>> existingPins,
            @JsonProperty("eligiblePins") Optional<? extends List<CollectionPinMetadata>> eligiblePins) {
        Utils.checkNotNull(existingPins, "existingPins");
        Utils.checkNotNull(eligiblePins, "eligiblePins");
        this.existingPins = existingPins;
        this.eligiblePins = eligiblePins;
    }
    
    public CollectionPinnedMetadata() {
        this(Optional.empty(), Optional.empty());
    }

    /**
     * List of targets this Collection is pinned to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CollectionPinTarget>> existingPins() {
        return (Optional<List<CollectionPinTarget>>) existingPins;
    }

    /**
     * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CollectionPinMetadata>> eligiblePins() {
        return (Optional<List<CollectionPinMetadata>>) eligiblePins;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * List of targets this Collection is pinned to.
     */
    public CollectionPinnedMetadata withExistingPins(List<CollectionPinTarget> existingPins) {
        Utils.checkNotNull(existingPins, "existingPins");
        this.existingPins = Optional.ofNullable(existingPins);
        return this;
    }

    /**
     * List of targets this Collection is pinned to.
     */
    public CollectionPinnedMetadata withExistingPins(Optional<? extends List<CollectionPinTarget>> existingPins) {
        Utils.checkNotNull(existingPins, "existingPins");
        this.existingPins = existingPins;
        return this;
    }

    /**
     * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
     */
    public CollectionPinnedMetadata withEligiblePins(List<CollectionPinMetadata> eligiblePins) {
        Utils.checkNotNull(eligiblePins, "eligiblePins");
        this.eligiblePins = Optional.ofNullable(eligiblePins);
        return this;
    }

    /**
     * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
     */
    public CollectionPinnedMetadata withEligiblePins(Optional<? extends List<CollectionPinMetadata>> eligiblePins) {
        Utils.checkNotNull(eligiblePins, "eligiblePins");
        this.eligiblePins = eligiblePins;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CollectionPinnedMetadata other = (CollectionPinnedMetadata) o;
        return 
            Objects.deepEquals(this.existingPins, other.existingPins) &&
            Objects.deepEquals(this.eligiblePins, other.eligiblePins);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            existingPins,
            eligiblePins);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CollectionPinnedMetadata.class,
                "existingPins", existingPins,
                "eligiblePins", eligiblePins);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<CollectionPinTarget>> existingPins = Optional.empty();
 
        private Optional<? extends List<CollectionPinMetadata>> eligiblePins = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * List of targets this Collection is pinned to.
         */
        public Builder existingPins(List<CollectionPinTarget> existingPins) {
            Utils.checkNotNull(existingPins, "existingPins");
            this.existingPins = Optional.ofNullable(existingPins);
            return this;
        }

        /**
         * List of targets this Collection is pinned to.
         */
        public Builder existingPins(Optional<? extends List<CollectionPinTarget>> existingPins) {
            Utils.checkNotNull(existingPins, "existingPins");
            this.existingPins = existingPins;
            return this;
        }

        /**
         * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
         */
        public Builder eligiblePins(List<CollectionPinMetadata> eligiblePins) {
            Utils.checkNotNull(eligiblePins, "eligiblePins");
            this.eligiblePins = Optional.ofNullable(eligiblePins);
            return this;
        }

        /**
         * List of targets this Collection can be pinned to, excluding the targets this Collection is already pinned to. We also include Collection ID already is pinned to each eligible target, which will be 0 if the target has no pinned Collection.
         */
        public Builder eligiblePins(Optional<? extends List<CollectionPinMetadata>> eligiblePins) {
            Utils.checkNotNull(eligiblePins, "eligiblePins");
            this.eligiblePins = eligiblePins;
            return this;
        }
        
        public CollectionPinnedMetadata build() {
            return new CollectionPinnedMetadata(
                existingPins,
                eligiblePins);
        }
    }
}
