/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;

public class SearchResult {

    /**
     * An array of entities in the work graph retrieved via a data request.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("structuredResults")
    private Optional<? extends List<StructuredResult>> structuredResults;

    /**
     * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("trackingToken")
    private Optional<String> trackingToken;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("document")
    private Optional<? extends Document> document;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;

    @JsonProperty("url")
    private String url;

    /**
     * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nativeAppUrl")
    private Optional<String> nativeAppUrl;

    /**
     * Text content from the result document which contains search query terms, if available.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("snippets")
    private Optional<? extends List<SearchResultSnippet>> snippets;

    /**
     * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullText")
    private Optional<String> fullText;

    /**
     * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullTextList")
    private Optional<? extends List<String>> fullTextList;

    /**
     * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("relatedResults")
    private Optional<? extends List<RelatedDocuments>> relatedResults;

    /**
     * A list of results that should be displayed as associated with this result.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clusteredResults")
    private Optional<? extends List<SearchResult>> clusteredResults;

    /**
     * A list of results that should be displayed as associated with this result.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allClusteredResults")
    private Optional<? extends List<ClusterGroup>> allClusteredResults;

    /**
     * The total number of attachments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("attachmentCount")
    private Optional<Long> attachmentCount;

    /**
     * A (potentially partial) list of results representing documents attached to the main result document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("attachments")
    private Optional<? extends List<SearchResult>> attachments;

    /**
     * A list of results that should be displayed as backlinks of this result in reverse chronological order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backlinkResults")
    private Optional<? extends List<SearchResult>> backlinkResults;

    /**
     * The reason for inclusion of clusteredResults.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clusterType")
    private Optional<? extends ClusterTypeEnum> clusterType;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mustIncludeSuggestions")
    private Optional<? extends QuerySuggestionList> mustIncludeSuggestions;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("querySuggestion")
    private Optional<? extends QuerySuggestion> querySuggestion;

    /**
     * The level of visual distinction that should be given to a result.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("prominence")
    private Optional<? extends SearchResultProminenceEnum> prominence;

    /**
     * Additional context for the relationship between the result and the document it's attached to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("attachmentContext")
    private Optional<String> attachmentContext;

    /**
     * A list of pins associated with this search result.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pins")
    private Optional<? extends List<PinDocument>> pins;

    @JsonCreator
    public SearchResult(
            @JsonProperty("structuredResults") Optional<? extends List<StructuredResult>> structuredResults,
            @JsonProperty("trackingToken") Optional<String> trackingToken,
            @JsonProperty("document") Optional<? extends Document> document,
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("url") String url,
            @JsonProperty("nativeAppUrl") Optional<String> nativeAppUrl,
            @JsonProperty("snippets") Optional<? extends List<SearchResultSnippet>> snippets,
            @JsonProperty("fullText") Optional<String> fullText,
            @JsonProperty("fullTextList") Optional<? extends List<String>> fullTextList,
            @JsonProperty("relatedResults") Optional<? extends List<RelatedDocuments>> relatedResults,
            @JsonProperty("clusteredResults") Optional<? extends List<SearchResult>> clusteredResults,
            @JsonProperty("allClusteredResults") Optional<? extends List<ClusterGroup>> allClusteredResults,
            @JsonProperty("attachmentCount") Optional<Long> attachmentCount,
            @JsonProperty("attachments") Optional<? extends List<SearchResult>> attachments,
            @JsonProperty("backlinkResults") Optional<? extends List<SearchResult>> backlinkResults,
            @JsonProperty("clusterType") Optional<? extends ClusterTypeEnum> clusterType,
            @JsonProperty("mustIncludeSuggestions") Optional<? extends QuerySuggestionList> mustIncludeSuggestions,
            @JsonProperty("querySuggestion") Optional<? extends QuerySuggestion> querySuggestion,
            @JsonProperty("prominence") Optional<? extends SearchResultProminenceEnum> prominence,
            @JsonProperty("attachmentContext") Optional<String> attachmentContext,
            @JsonProperty("pins") Optional<? extends List<PinDocument>> pins) {
        Utils.checkNotNull(structuredResults, "structuredResults");
        Utils.checkNotNull(trackingToken, "trackingToken");
        Utils.checkNotNull(document, "document");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(url, "url");
        Utils.checkNotNull(nativeAppUrl, "nativeAppUrl");
        Utils.checkNotNull(snippets, "snippets");
        Utils.checkNotNull(fullText, "fullText");
        Utils.checkNotNull(fullTextList, "fullTextList");
        Utils.checkNotNull(relatedResults, "relatedResults");
        Utils.checkNotNull(clusteredResults, "clusteredResults");
        Utils.checkNotNull(allClusteredResults, "allClusteredResults");
        Utils.checkNotNull(attachmentCount, "attachmentCount");
        Utils.checkNotNull(attachments, "attachments");
        Utils.checkNotNull(backlinkResults, "backlinkResults");
        Utils.checkNotNull(clusterType, "clusterType");
        Utils.checkNotNull(mustIncludeSuggestions, "mustIncludeSuggestions");
        Utils.checkNotNull(querySuggestion, "querySuggestion");
        Utils.checkNotNull(prominence, "prominence");
        Utils.checkNotNull(attachmentContext, "attachmentContext");
        Utils.checkNotNull(pins, "pins");
        this.structuredResults = structuredResults;
        this.trackingToken = trackingToken;
        this.document = document;
        this.title = title;
        this.url = url;
        this.nativeAppUrl = nativeAppUrl;
        this.snippets = snippets;
        this.fullText = fullText;
        this.fullTextList = fullTextList;
        this.relatedResults = relatedResults;
        this.clusteredResults = clusteredResults;
        this.allClusteredResults = allClusteredResults;
        this.attachmentCount = attachmentCount;
        this.attachments = attachments;
        this.backlinkResults = backlinkResults;
        this.clusterType = clusterType;
        this.mustIncludeSuggestions = mustIncludeSuggestions;
        this.querySuggestion = querySuggestion;
        this.prominence = prominence;
        this.attachmentContext = attachmentContext;
        this.pins = pins;
    }
    
    public SearchResult(
            String url) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), url, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * An array of entities in the work graph retrieved via a data request.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<StructuredResult>> structuredResults() {
        return (Optional<List<StructuredResult>>) structuredResults;
    }

    /**
     * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
     */
    @JsonIgnore
    public Optional<String> trackingToken() {
        return trackingToken;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Document> document() {
        return (Optional<Document>) document;
    }

    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    @JsonIgnore
    public String url() {
        return url;
    }

    /**
     * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
     */
    @JsonIgnore
    public Optional<String> nativeAppUrl() {
        return nativeAppUrl;
    }

    /**
     * Text content from the result document which contains search query terms, if available.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SearchResultSnippet>> snippets() {
        return (Optional<List<SearchResultSnippet>>) snippets;
    }

    /**
     * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    @JsonIgnore
    public Optional<String> fullText() {
        return fullText;
    }

    /**
     * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> fullTextList() {
        return (Optional<List<String>>) fullTextList;
    }

    /**
     * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<RelatedDocuments>> relatedResults() {
        return (Optional<List<RelatedDocuments>>) relatedResults;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SearchResult>> clusteredResults() {
        return (Optional<List<SearchResult>>) clusteredResults;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ClusterGroup>> allClusteredResults() {
        return (Optional<List<ClusterGroup>>) allClusteredResults;
    }

    /**
     * The total number of attachments.
     */
    @JsonIgnore
    public Optional<Long> attachmentCount() {
        return attachmentCount;
    }

    /**
     * A (potentially partial) list of results representing documents attached to the main result document.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SearchResult>> attachments() {
        return (Optional<List<SearchResult>>) attachments;
    }

    /**
     * A list of results that should be displayed as backlinks of this result in reverse chronological order.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SearchResult>> backlinkResults() {
        return (Optional<List<SearchResult>>) backlinkResults;
    }

    /**
     * The reason for inclusion of clusteredResults.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ClusterTypeEnum> clusterType() {
        return (Optional<ClusterTypeEnum>) clusterType;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<QuerySuggestionList> mustIncludeSuggestions() {
        return (Optional<QuerySuggestionList>) mustIncludeSuggestions;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<QuerySuggestion> querySuggestion() {
        return (Optional<QuerySuggestion>) querySuggestion;
    }

    /**
     * The level of visual distinction that should be given to a result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SearchResultProminenceEnum> prominence() {
        return (Optional<SearchResultProminenceEnum>) prominence;
    }

    /**
     * Additional context for the relationship between the result and the document it's attached to.
     */
    @JsonIgnore
    public Optional<String> attachmentContext() {
        return attachmentContext;
    }

    /**
     * A list of pins associated with this search result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PinDocument>> pins() {
        return (Optional<List<PinDocument>>) pins;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * An array of entities in the work graph retrieved via a data request.
     */
    public SearchResult withStructuredResults(List<StructuredResult> structuredResults) {
        Utils.checkNotNull(structuredResults, "structuredResults");
        this.structuredResults = Optional.ofNullable(structuredResults);
        return this;
    }

    /**
     * An array of entities in the work graph retrieved via a data request.
     */
    public SearchResult withStructuredResults(Optional<? extends List<StructuredResult>> structuredResults) {
        Utils.checkNotNull(structuredResults, "structuredResults");
        this.structuredResults = structuredResults;
        return this;
    }

    /**
     * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
     */
    public SearchResult withTrackingToken(String trackingToken) {
        Utils.checkNotNull(trackingToken, "trackingToken");
        this.trackingToken = Optional.ofNullable(trackingToken);
        return this;
    }

    /**
     * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
     */
    public SearchResult withTrackingToken(Optional<String> trackingToken) {
        Utils.checkNotNull(trackingToken, "trackingToken");
        this.trackingToken = trackingToken;
        return this;
    }

    public SearchResult withDocument(Document document) {
        Utils.checkNotNull(document, "document");
        this.document = Optional.ofNullable(document);
        return this;
    }

    public SearchResult withDocument(Optional<? extends Document> document) {
        Utils.checkNotNull(document, "document");
        this.document = document;
        return this;
    }

    public SearchResult withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }

    public SearchResult withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    public SearchResult withUrl(String url) {
        Utils.checkNotNull(url, "url");
        this.url = url;
        return this;
    }

    /**
     * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
     */
    public SearchResult withNativeAppUrl(String nativeAppUrl) {
        Utils.checkNotNull(nativeAppUrl, "nativeAppUrl");
        this.nativeAppUrl = Optional.ofNullable(nativeAppUrl);
        return this;
    }

    /**
     * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
     */
    public SearchResult withNativeAppUrl(Optional<String> nativeAppUrl) {
        Utils.checkNotNull(nativeAppUrl, "nativeAppUrl");
        this.nativeAppUrl = nativeAppUrl;
        return this;
    }

    /**
     * Text content from the result document which contains search query terms, if available.
     */
    public SearchResult withSnippets(List<SearchResultSnippet> snippets) {
        Utils.checkNotNull(snippets, "snippets");
        this.snippets = Optional.ofNullable(snippets);
        return this;
    }

    /**
     * Text content from the result document which contains search query terms, if available.
     */
    public SearchResult withSnippets(Optional<? extends List<SearchResultSnippet>> snippets) {
        Utils.checkNotNull(snippets, "snippets");
        this.snippets = snippets;
        return this;
    }

    /**
     * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    public SearchResult withFullText(String fullText) {
        Utils.checkNotNull(fullText, "fullText");
        this.fullText = Optional.ofNullable(fullText);
        return this;
    }

    /**
     * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    public SearchResult withFullText(Optional<String> fullText) {
        Utils.checkNotNull(fullText, "fullText");
        this.fullText = fullText;
        return this;
    }

    /**
     * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    public SearchResult withFullTextList(List<String> fullTextList) {
        Utils.checkNotNull(fullTextList, "fullTextList");
        this.fullTextList = Optional.ofNullable(fullTextList);
        return this;
    }

    /**
     * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
     */
    public SearchResult withFullTextList(Optional<? extends List<String>> fullTextList) {
        Utils.checkNotNull(fullTextList, "fullTextList");
        this.fullTextList = fullTextList;
        return this;
    }

    /**
     * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
     */
    public SearchResult withRelatedResults(List<RelatedDocuments> relatedResults) {
        Utils.checkNotNull(relatedResults, "relatedResults");
        this.relatedResults = Optional.ofNullable(relatedResults);
        return this;
    }

    /**
     * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
     */
    public SearchResult withRelatedResults(Optional<? extends List<RelatedDocuments>> relatedResults) {
        Utils.checkNotNull(relatedResults, "relatedResults");
        this.relatedResults = relatedResults;
        return this;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    public SearchResult withClusteredResults(List<SearchResult> clusteredResults) {
        Utils.checkNotNull(clusteredResults, "clusteredResults");
        this.clusteredResults = Optional.ofNullable(clusteredResults);
        return this;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    public SearchResult withClusteredResults(Optional<? extends List<SearchResult>> clusteredResults) {
        Utils.checkNotNull(clusteredResults, "clusteredResults");
        this.clusteredResults = clusteredResults;
        return this;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    public SearchResult withAllClusteredResults(List<ClusterGroup> allClusteredResults) {
        Utils.checkNotNull(allClusteredResults, "allClusteredResults");
        this.allClusteredResults = Optional.ofNullable(allClusteredResults);
        return this;
    }

    /**
     * A list of results that should be displayed as associated with this result.
     */
    public SearchResult withAllClusteredResults(Optional<? extends List<ClusterGroup>> allClusteredResults) {
        Utils.checkNotNull(allClusteredResults, "allClusteredResults");
        this.allClusteredResults = allClusteredResults;
        return this;
    }

    /**
     * The total number of attachments.
     */
    public SearchResult withAttachmentCount(long attachmentCount) {
        Utils.checkNotNull(attachmentCount, "attachmentCount");
        this.attachmentCount = Optional.ofNullable(attachmentCount);
        return this;
    }

    /**
     * The total number of attachments.
     */
    public SearchResult withAttachmentCount(Optional<Long> attachmentCount) {
        Utils.checkNotNull(attachmentCount, "attachmentCount");
        this.attachmentCount = attachmentCount;
        return this;
    }

    /**
     * A (potentially partial) list of results representing documents attached to the main result document.
     */
    public SearchResult withAttachments(List<SearchResult> attachments) {
        Utils.checkNotNull(attachments, "attachments");
        this.attachments = Optional.ofNullable(attachments);
        return this;
    }

    /**
     * A (potentially partial) list of results representing documents attached to the main result document.
     */
    public SearchResult withAttachments(Optional<? extends List<SearchResult>> attachments) {
        Utils.checkNotNull(attachments, "attachments");
        this.attachments = attachments;
        return this;
    }

    /**
     * A list of results that should be displayed as backlinks of this result in reverse chronological order.
     */
    public SearchResult withBacklinkResults(List<SearchResult> backlinkResults) {
        Utils.checkNotNull(backlinkResults, "backlinkResults");
        this.backlinkResults = Optional.ofNullable(backlinkResults);
        return this;
    }

    /**
     * A list of results that should be displayed as backlinks of this result in reverse chronological order.
     */
    public SearchResult withBacklinkResults(Optional<? extends List<SearchResult>> backlinkResults) {
        Utils.checkNotNull(backlinkResults, "backlinkResults");
        this.backlinkResults = backlinkResults;
        return this;
    }

    /**
     * The reason for inclusion of clusteredResults.
     */
    public SearchResult withClusterType(ClusterTypeEnum clusterType) {
        Utils.checkNotNull(clusterType, "clusterType");
        this.clusterType = Optional.ofNullable(clusterType);
        return this;
    }

    /**
     * The reason for inclusion of clusteredResults.
     */
    public SearchResult withClusterType(Optional<? extends ClusterTypeEnum> clusterType) {
        Utils.checkNotNull(clusterType, "clusterType");
        this.clusterType = clusterType;
        return this;
    }

    public SearchResult withMustIncludeSuggestions(QuerySuggestionList mustIncludeSuggestions) {
        Utils.checkNotNull(mustIncludeSuggestions, "mustIncludeSuggestions");
        this.mustIncludeSuggestions = Optional.ofNullable(mustIncludeSuggestions);
        return this;
    }

    public SearchResult withMustIncludeSuggestions(Optional<? extends QuerySuggestionList> mustIncludeSuggestions) {
        Utils.checkNotNull(mustIncludeSuggestions, "mustIncludeSuggestions");
        this.mustIncludeSuggestions = mustIncludeSuggestions;
        return this;
    }

    public SearchResult withQuerySuggestion(QuerySuggestion querySuggestion) {
        Utils.checkNotNull(querySuggestion, "querySuggestion");
        this.querySuggestion = Optional.ofNullable(querySuggestion);
        return this;
    }

    public SearchResult withQuerySuggestion(Optional<? extends QuerySuggestion> querySuggestion) {
        Utils.checkNotNull(querySuggestion, "querySuggestion");
        this.querySuggestion = querySuggestion;
        return this;
    }

    /**
     * The level of visual distinction that should be given to a result.
     */
    public SearchResult withProminence(SearchResultProminenceEnum prominence) {
        Utils.checkNotNull(prominence, "prominence");
        this.prominence = Optional.ofNullable(prominence);
        return this;
    }

    /**
     * The level of visual distinction that should be given to a result.
     */
    public SearchResult withProminence(Optional<? extends SearchResultProminenceEnum> prominence) {
        Utils.checkNotNull(prominence, "prominence");
        this.prominence = prominence;
        return this;
    }

    /**
     * Additional context for the relationship between the result and the document it's attached to.
     */
    public SearchResult withAttachmentContext(String attachmentContext) {
        Utils.checkNotNull(attachmentContext, "attachmentContext");
        this.attachmentContext = Optional.ofNullable(attachmentContext);
        return this;
    }

    /**
     * Additional context for the relationship between the result and the document it's attached to.
     */
    public SearchResult withAttachmentContext(Optional<String> attachmentContext) {
        Utils.checkNotNull(attachmentContext, "attachmentContext");
        this.attachmentContext = attachmentContext;
        return this;
    }

    /**
     * A list of pins associated with this search result.
     */
    public SearchResult withPins(List<PinDocument> pins) {
        Utils.checkNotNull(pins, "pins");
        this.pins = Optional.ofNullable(pins);
        return this;
    }

    /**
     * A list of pins associated with this search result.
     */
    public SearchResult withPins(Optional<? extends List<PinDocument>> pins) {
        Utils.checkNotNull(pins, "pins");
        this.pins = pins;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SearchResult other = (SearchResult) o;
        return 
            Utils.enhancedDeepEquals(this.structuredResults, other.structuredResults) &&
            Utils.enhancedDeepEquals(this.trackingToken, other.trackingToken) &&
            Utils.enhancedDeepEquals(this.document, other.document) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.url, other.url) &&
            Utils.enhancedDeepEquals(this.nativeAppUrl, other.nativeAppUrl) &&
            Utils.enhancedDeepEquals(this.snippets, other.snippets) &&
            Utils.enhancedDeepEquals(this.fullText, other.fullText) &&
            Utils.enhancedDeepEquals(this.fullTextList, other.fullTextList) &&
            Utils.enhancedDeepEquals(this.relatedResults, other.relatedResults) &&
            Utils.enhancedDeepEquals(this.clusteredResults, other.clusteredResults) &&
            Utils.enhancedDeepEquals(this.allClusteredResults, other.allClusteredResults) &&
            Utils.enhancedDeepEquals(this.attachmentCount, other.attachmentCount) &&
            Utils.enhancedDeepEquals(this.attachments, other.attachments) &&
            Utils.enhancedDeepEquals(this.backlinkResults, other.backlinkResults) &&
            Utils.enhancedDeepEquals(this.clusterType, other.clusterType) &&
            Utils.enhancedDeepEquals(this.mustIncludeSuggestions, other.mustIncludeSuggestions) &&
            Utils.enhancedDeepEquals(this.querySuggestion, other.querySuggestion) &&
            Utils.enhancedDeepEquals(this.prominence, other.prominence) &&
            Utils.enhancedDeepEquals(this.attachmentContext, other.attachmentContext) &&
            Utils.enhancedDeepEquals(this.pins, other.pins);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            structuredResults,
            trackingToken,
            document,
            title,
            url,
            nativeAppUrl,
            snippets,
            fullText,
            fullTextList,
            relatedResults,
            clusteredResults,
            allClusteredResults,
            attachmentCount,
            attachments,
            backlinkResults,
            clusterType,
            mustIncludeSuggestions,
            querySuggestion,
            prominence,
            attachmentContext,
            pins);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SearchResult.class,
                "structuredResults", structuredResults,
                "trackingToken", trackingToken,
                "document", document,
                "title", title,
                "url", url,
                "nativeAppUrl", nativeAppUrl,
                "snippets", snippets,
                "fullText", fullText,
                "fullTextList", fullTextList,
                "relatedResults", relatedResults,
                "clusteredResults", clusteredResults,
                "allClusteredResults", allClusteredResults,
                "attachmentCount", attachmentCount,
                "attachments", attachments,
                "backlinkResults", backlinkResults,
                "clusterType", clusterType,
                "mustIncludeSuggestions", mustIncludeSuggestions,
                "querySuggestion", querySuggestion,
                "prominence", prominence,
                "attachmentContext", attachmentContext,
                "pins", pins);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<StructuredResult>> structuredResults = Optional.empty();
 
        private Optional<String> trackingToken = Optional.empty();
 
        private Optional<? extends Document> document = Optional.empty();
 
        private Optional<String> title = Optional.empty();
 
        private String url;
 
        private Optional<String> nativeAppUrl = Optional.empty();
 
        private Optional<? extends List<SearchResultSnippet>> snippets = Optional.empty();
 
        private Optional<String> fullText = Optional.empty();
 
        private Optional<? extends List<String>> fullTextList = Optional.empty();
 
        private Optional<? extends List<RelatedDocuments>> relatedResults = Optional.empty();
 
        private Optional<? extends List<SearchResult>> clusteredResults = Optional.empty();
 
        private Optional<? extends List<ClusterGroup>> allClusteredResults = Optional.empty();
 
        private Optional<Long> attachmentCount = Optional.empty();
 
        private Optional<? extends List<SearchResult>> attachments = Optional.empty();
 
        private Optional<? extends List<SearchResult>> backlinkResults = Optional.empty();
 
        private Optional<? extends ClusterTypeEnum> clusterType = Optional.empty();
 
        private Optional<? extends QuerySuggestionList> mustIncludeSuggestions = Optional.empty();
 
        private Optional<? extends QuerySuggestion> querySuggestion = Optional.empty();
 
        private Optional<? extends SearchResultProminenceEnum> prominence = Optional.empty();
 
        private Optional<String> attachmentContext = Optional.empty();
 
        private Optional<? extends List<PinDocument>> pins = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * An array of entities in the work graph retrieved via a data request.
         */
        public Builder structuredResults(List<StructuredResult> structuredResults) {
            Utils.checkNotNull(structuredResults, "structuredResults");
            this.structuredResults = Optional.ofNullable(structuredResults);
            return this;
        }

        /**
         * An array of entities in the work graph retrieved via a data request.
         */
        public Builder structuredResults(Optional<? extends List<StructuredResult>> structuredResults) {
            Utils.checkNotNull(structuredResults, "structuredResults");
            this.structuredResults = structuredResults;
            return this;
        }

        /**
         * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
         */
        public Builder trackingToken(String trackingToken) {
            Utils.checkNotNull(trackingToken, "trackingToken");
            this.trackingToken = Optional.ofNullable(trackingToken);
            return this;
        }

        /**
         * An opaque token that represents this particular result in this particular query. To be used for /feedback reporting.
         */
        public Builder trackingToken(Optional<String> trackingToken) {
            Utils.checkNotNull(trackingToken, "trackingToken");
            this.trackingToken = trackingToken;
            return this;
        }

        public Builder document(Document document) {
            Utils.checkNotNull(document, "document");
            this.document = Optional.ofNullable(document);
            return this;
        }

        public Builder document(Optional<? extends Document> document) {
            Utils.checkNotNull(document, "document");
            this.document = document;
            return this;
        }

        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }

        public Builder url(String url) {
            Utils.checkNotNull(url, "url");
            this.url = url;
            return this;
        }

        /**
         * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
         */
        public Builder nativeAppUrl(String nativeAppUrl) {
            Utils.checkNotNull(nativeAppUrl, "nativeAppUrl");
            this.nativeAppUrl = Optional.ofNullable(nativeAppUrl);
            return this;
        }

        /**
         * A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...).
         */
        public Builder nativeAppUrl(Optional<String> nativeAppUrl) {
            Utils.checkNotNull(nativeAppUrl, "nativeAppUrl");
            this.nativeAppUrl = nativeAppUrl;
            return this;
        }

        /**
         * Text content from the result document which contains search query terms, if available.
         */
        public Builder snippets(List<SearchResultSnippet> snippets) {
            Utils.checkNotNull(snippets, "snippets");
            this.snippets = Optional.ofNullable(snippets);
            return this;
        }

        /**
         * Text content from the result document which contains search query terms, if available.
         */
        public Builder snippets(Optional<? extends List<SearchResultSnippet>> snippets) {
            Utils.checkNotNull(snippets, "snippets");
            this.snippets = snippets;
            return this;
        }

        /**
         * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
         */
        public Builder fullText(String fullText) {
            Utils.checkNotNull(fullText, "fullText");
            this.fullText = Optional.ofNullable(fullText);
            return this;
        }

        /**
         * The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack).
         */
        public Builder fullText(Optional<String> fullText) {
            Utils.checkNotNull(fullText, "fullText");
            this.fullText = fullText;
            return this;
        }

        /**
         * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
         */
        public Builder fullTextList(List<String> fullTextList) {
            Utils.checkNotNull(fullTextList, "fullTextList");
            this.fullTextList = Optional.ofNullable(fullTextList);
            return this;
        }

        /**
         * The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack).
         */
        public Builder fullTextList(Optional<? extends List<String>> fullTextList) {
            Utils.checkNotNull(fullTextList, "fullTextList");
            this.fullTextList = fullTextList;
            return this;
        }

        /**
         * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
         */
        public Builder relatedResults(List<RelatedDocuments> relatedResults) {
            Utils.checkNotNull(relatedResults, "relatedResults");
            this.relatedResults = Optional.ofNullable(relatedResults);
            return this;
        }

        /**
         * A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP.
         */
        public Builder relatedResults(Optional<? extends List<RelatedDocuments>> relatedResults) {
            Utils.checkNotNull(relatedResults, "relatedResults");
            this.relatedResults = relatedResults;
            return this;
        }

        /**
         * A list of results that should be displayed as associated with this result.
         */
        public Builder clusteredResults(List<SearchResult> clusteredResults) {
            Utils.checkNotNull(clusteredResults, "clusteredResults");
            this.clusteredResults = Optional.ofNullable(clusteredResults);
            return this;
        }

        /**
         * A list of results that should be displayed as associated with this result.
         */
        public Builder clusteredResults(Optional<? extends List<SearchResult>> clusteredResults) {
            Utils.checkNotNull(clusteredResults, "clusteredResults");
            this.clusteredResults = clusteredResults;
            return this;
        }

        /**
         * A list of results that should be displayed as associated with this result.
         */
        public Builder allClusteredResults(List<ClusterGroup> allClusteredResults) {
            Utils.checkNotNull(allClusteredResults, "allClusteredResults");
            this.allClusteredResults = Optional.ofNullable(allClusteredResults);
            return this;
        }

        /**
         * A list of results that should be displayed as associated with this result.
         */
        public Builder allClusteredResults(Optional<? extends List<ClusterGroup>> allClusteredResults) {
            Utils.checkNotNull(allClusteredResults, "allClusteredResults");
            this.allClusteredResults = allClusteredResults;
            return this;
        }

        /**
         * The total number of attachments.
         */
        public Builder attachmentCount(long attachmentCount) {
            Utils.checkNotNull(attachmentCount, "attachmentCount");
            this.attachmentCount = Optional.ofNullable(attachmentCount);
            return this;
        }

        /**
         * The total number of attachments.
         */
        public Builder attachmentCount(Optional<Long> attachmentCount) {
            Utils.checkNotNull(attachmentCount, "attachmentCount");
            this.attachmentCount = attachmentCount;
            return this;
        }

        /**
         * A (potentially partial) list of results representing documents attached to the main result document.
         */
        public Builder attachments(List<SearchResult> attachments) {
            Utils.checkNotNull(attachments, "attachments");
            this.attachments = Optional.ofNullable(attachments);
            return this;
        }

        /**
         * A (potentially partial) list of results representing documents attached to the main result document.
         */
        public Builder attachments(Optional<? extends List<SearchResult>> attachments) {
            Utils.checkNotNull(attachments, "attachments");
            this.attachments = attachments;
            return this;
        }

        /**
         * A list of results that should be displayed as backlinks of this result in reverse chronological order.
         */
        public Builder backlinkResults(List<SearchResult> backlinkResults) {
            Utils.checkNotNull(backlinkResults, "backlinkResults");
            this.backlinkResults = Optional.ofNullable(backlinkResults);
            return this;
        }

        /**
         * A list of results that should be displayed as backlinks of this result in reverse chronological order.
         */
        public Builder backlinkResults(Optional<? extends List<SearchResult>> backlinkResults) {
            Utils.checkNotNull(backlinkResults, "backlinkResults");
            this.backlinkResults = backlinkResults;
            return this;
        }

        /**
         * The reason for inclusion of clusteredResults.
         */
        public Builder clusterType(ClusterTypeEnum clusterType) {
            Utils.checkNotNull(clusterType, "clusterType");
            this.clusterType = Optional.ofNullable(clusterType);
            return this;
        }

        /**
         * The reason for inclusion of clusteredResults.
         */
        public Builder clusterType(Optional<? extends ClusterTypeEnum> clusterType) {
            Utils.checkNotNull(clusterType, "clusterType");
            this.clusterType = clusterType;
            return this;
        }

        public Builder mustIncludeSuggestions(QuerySuggestionList mustIncludeSuggestions) {
            Utils.checkNotNull(mustIncludeSuggestions, "mustIncludeSuggestions");
            this.mustIncludeSuggestions = Optional.ofNullable(mustIncludeSuggestions);
            return this;
        }

        public Builder mustIncludeSuggestions(Optional<? extends QuerySuggestionList> mustIncludeSuggestions) {
            Utils.checkNotNull(mustIncludeSuggestions, "mustIncludeSuggestions");
            this.mustIncludeSuggestions = mustIncludeSuggestions;
            return this;
        }

        public Builder querySuggestion(QuerySuggestion querySuggestion) {
            Utils.checkNotNull(querySuggestion, "querySuggestion");
            this.querySuggestion = Optional.ofNullable(querySuggestion);
            return this;
        }

        public Builder querySuggestion(Optional<? extends QuerySuggestion> querySuggestion) {
            Utils.checkNotNull(querySuggestion, "querySuggestion");
            this.querySuggestion = querySuggestion;
            return this;
        }

        /**
         * The level of visual distinction that should be given to a result.
         */
        public Builder prominence(SearchResultProminenceEnum prominence) {
            Utils.checkNotNull(prominence, "prominence");
            this.prominence = Optional.ofNullable(prominence);
            return this;
        }

        /**
         * The level of visual distinction that should be given to a result.
         */
        public Builder prominence(Optional<? extends SearchResultProminenceEnum> prominence) {
            Utils.checkNotNull(prominence, "prominence");
            this.prominence = prominence;
            return this;
        }

        /**
         * Additional context for the relationship between the result and the document it's attached to.
         */
        public Builder attachmentContext(String attachmentContext) {
            Utils.checkNotNull(attachmentContext, "attachmentContext");
            this.attachmentContext = Optional.ofNullable(attachmentContext);
            return this;
        }

        /**
         * Additional context for the relationship between the result and the document it's attached to.
         */
        public Builder attachmentContext(Optional<String> attachmentContext) {
            Utils.checkNotNull(attachmentContext, "attachmentContext");
            this.attachmentContext = attachmentContext;
            return this;
        }

        /**
         * A list of pins associated with this search result.
         */
        public Builder pins(List<PinDocument> pins) {
            Utils.checkNotNull(pins, "pins");
            this.pins = Optional.ofNullable(pins);
            return this;
        }

        /**
         * A list of pins associated with this search result.
         */
        public Builder pins(Optional<? extends List<PinDocument>> pins) {
            Utils.checkNotNull(pins, "pins");
            this.pins = pins;
            return this;
        }
        
        public SearchResult build() {
            return new SearchResult(
                structuredResults,
                trackingToken,
                document,
                title,
                url,
                nativeAppUrl,
                snippets,
                fullText,
                fullTextList,
                relatedResults,
                clusteredResults,
                allClusteredResults,
                attachmentCount,
                attachments,
                backlinkResults,
                clusterType,
                mustIncludeSuggestions,
                querySuggestion,
                prominence,
                attachmentContext,
                pins);
        }
    }
}
