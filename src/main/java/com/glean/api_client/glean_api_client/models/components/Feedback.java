/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

public class Feedback {

    /**
     * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("category")
    private Optional<? extends FeedbackCategory> category;

    /**
     * A list of server-generated trackingTokens to which this event applies.
     */
    @JsonProperty("trackingTokens")
    private List<String> trackingTokens;

    /**
     * The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
     */
    @JsonProperty("event")
    private Event event;

    /**
     * Position of the element in the case that the client controls order (such as feed and autocomplete).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("position")
    private Optional<Long> position;

    /**
     * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payload")
    private Optional<String> payload;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sessionInfo")
    private Optional<? extends SessionInfo> sessionInfo;

    /**
     * The ISO 8601 timestamp when the event occured.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timestamp")
    private Optional<OffsetDateTime> timestamp;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("user")
    private Optional<? extends User> user;

    /**
     * The path the client was at when the feedback event triggered.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pathname")
    private Optional<String> pathname;

    /**
     * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("channels")
    private Optional<? extends List<FeedbackChannel>> channels;

    /**
     * The URL the client was at when the feedback event triggered.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("url")
    private Optional<String> url;

    /**
     * The UI element tree associated with the event, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uiTree")
    private Optional<? extends List<String>> uiTree;

    /**
     * The UI element associated with the event, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uiElement")
    private Optional<String> uiElement;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("manualFeedbackInfo")
    private Optional<? extends ManualFeedbackInfo> manualFeedbackInfo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("seenFeedbackInfo")
    private Optional<? extends SeenFeedbackInfo> seenFeedbackInfo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userViewInfo")
    private Optional<? extends UserViewInfo> userViewInfo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("workflowFeedbackInfo")
    private Optional<? extends WorkflowFeedbackInfo> workflowFeedbackInfo;

    /**
     * The application ID of the client that sent the feedback event.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationId")
    private Optional<String> applicationId;

    /**
     * The agent ID of the client that sent the feedback event.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("agentId")
    private Optional<String> agentId;

    @JsonCreator
    public Feedback(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("category") Optional<? extends FeedbackCategory> category,
            @JsonProperty("trackingTokens") List<String> trackingTokens,
            @JsonProperty("event") Event event,
            @JsonProperty("position") Optional<Long> position,
            @JsonProperty("payload") Optional<String> payload,
            @JsonProperty("sessionInfo") Optional<? extends SessionInfo> sessionInfo,
            @JsonProperty("timestamp") Optional<OffsetDateTime> timestamp,
            @JsonProperty("user") Optional<? extends User> user,
            @JsonProperty("pathname") Optional<String> pathname,
            @JsonProperty("channels") Optional<? extends List<FeedbackChannel>> channels,
            @JsonProperty("url") Optional<String> url,
            @JsonProperty("uiTree") Optional<? extends List<String>> uiTree,
            @JsonProperty("uiElement") Optional<String> uiElement,
            @JsonProperty("manualFeedbackInfo") Optional<? extends ManualFeedbackInfo> manualFeedbackInfo,
            @JsonProperty("seenFeedbackInfo") Optional<? extends SeenFeedbackInfo> seenFeedbackInfo,
            @JsonProperty("userViewInfo") Optional<? extends UserViewInfo> userViewInfo,
            @JsonProperty("workflowFeedbackInfo") Optional<? extends WorkflowFeedbackInfo> workflowFeedbackInfo,
            @JsonProperty("applicationId") Optional<String> applicationId,
            @JsonProperty("agentId") Optional<String> agentId) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(category, "category");
        Utils.checkNotNull(trackingTokens, "trackingTokens");
        Utils.checkNotNull(event, "event");
        Utils.checkNotNull(position, "position");
        Utils.checkNotNull(payload, "payload");
        Utils.checkNotNull(sessionInfo, "sessionInfo");
        Utils.checkNotNull(timestamp, "timestamp");
        Utils.checkNotNull(user, "user");
        Utils.checkNotNull(pathname, "pathname");
        Utils.checkNotNull(channels, "channels");
        Utils.checkNotNull(url, "url");
        Utils.checkNotNull(uiTree, "uiTree");
        Utils.checkNotNull(uiElement, "uiElement");
        Utils.checkNotNull(manualFeedbackInfo, "manualFeedbackInfo");
        Utils.checkNotNull(seenFeedbackInfo, "seenFeedbackInfo");
        Utils.checkNotNull(userViewInfo, "userViewInfo");
        Utils.checkNotNull(workflowFeedbackInfo, "workflowFeedbackInfo");
        Utils.checkNotNull(applicationId, "applicationId");
        Utils.checkNotNull(agentId, "agentId");
        this.id = id;
        this.category = category;
        this.trackingTokens = trackingTokens;
        this.event = event;
        this.position = position;
        this.payload = payload;
        this.sessionInfo = sessionInfo;
        this.timestamp = timestamp;
        this.user = user;
        this.pathname = pathname;
        this.channels = channels;
        this.url = url;
        this.uiTree = uiTree;
        this.uiElement = uiElement;
        this.manualFeedbackInfo = manualFeedbackInfo;
        this.seenFeedbackInfo = seenFeedbackInfo;
        this.userViewInfo = userViewInfo;
        this.workflowFeedbackInfo = workflowFeedbackInfo;
        this.applicationId = applicationId;
        this.agentId = agentId;
    }
    
    public Feedback(
            List<String> trackingTokens,
            Event event) {
        this(Optional.empty(), Optional.empty(), trackingTokens, event, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<FeedbackCategory> category() {
        return (Optional<FeedbackCategory>) category;
    }

    /**
     * A list of server-generated trackingTokens to which this event applies.
     */
    @JsonIgnore
    public List<String> trackingTokens() {
        return trackingTokens;
    }

    /**
     * The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
     */
    @JsonIgnore
    public Event event() {
        return event;
    }

    /**
     * Position of the element in the case that the client controls order (such as feed and autocomplete).
     */
    @JsonIgnore
    public Optional<Long> position() {
        return position;
    }

    /**
     * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
     */
    @JsonIgnore
    public Optional<String> payload() {
        return payload;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SessionInfo> sessionInfo() {
        return (Optional<SessionInfo>) sessionInfo;
    }

    /**
     * The ISO 8601 timestamp when the event occured.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> timestamp() {
        return timestamp;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<User> user() {
        return (Optional<User>) user;
    }

    /**
     * The path the client was at when the feedback event triggered.
     */
    @JsonIgnore
    public Optional<String> pathname() {
        return pathname;
    }

    /**
     * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FeedbackChannel>> channels() {
        return (Optional<List<FeedbackChannel>>) channels;
    }

    /**
     * The URL the client was at when the feedback event triggered.
     */
    @JsonIgnore
    public Optional<String> url() {
        return url;
    }

    /**
     * The UI element tree associated with the event, if any.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> uiTree() {
        return (Optional<List<String>>) uiTree;
    }

    /**
     * The UI element associated with the event, if any.
     */
    @JsonIgnore
    public Optional<String> uiElement() {
        return uiElement;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ManualFeedbackInfo> manualFeedbackInfo() {
        return (Optional<ManualFeedbackInfo>) manualFeedbackInfo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SeenFeedbackInfo> seenFeedbackInfo() {
        return (Optional<SeenFeedbackInfo>) seenFeedbackInfo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<UserViewInfo> userViewInfo() {
        return (Optional<UserViewInfo>) userViewInfo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<WorkflowFeedbackInfo> workflowFeedbackInfo() {
        return (Optional<WorkflowFeedbackInfo>) workflowFeedbackInfo;
    }

    /**
     * The application ID of the client that sent the feedback event.
     */
    @JsonIgnore
    public Optional<String> applicationId() {
        return applicationId;
    }

    /**
     * The agent ID of the client that sent the feedback event.
     */
    @JsonIgnore
    public Optional<String> agentId() {
        return agentId;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
     */
    public Feedback withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
     */
    public Feedback withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
     */
    public Feedback withCategory(FeedbackCategory category) {
        Utils.checkNotNull(category, "category");
        this.category = Optional.ofNullable(category);
        return this;
    }

    /**
     * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
     */
    public Feedback withCategory(Optional<? extends FeedbackCategory> category) {
        Utils.checkNotNull(category, "category");
        this.category = category;
        return this;
    }

    /**
     * A list of server-generated trackingTokens to which this event applies.
     */
    public Feedback withTrackingTokens(List<String> trackingTokens) {
        Utils.checkNotNull(trackingTokens, "trackingTokens");
        this.trackingTokens = trackingTokens;
        return this;
    }

    /**
     * The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
     */
    public Feedback withEvent(Event event) {
        Utils.checkNotNull(event, "event");
        this.event = event;
        return this;
    }

    /**
     * Position of the element in the case that the client controls order (such as feed and autocomplete).
     */
    public Feedback withPosition(long position) {
        Utils.checkNotNull(position, "position");
        this.position = Optional.ofNullable(position);
        return this;
    }

    /**
     * Position of the element in the case that the client controls order (such as feed and autocomplete).
     */
    public Feedback withPosition(Optional<Long> position) {
        Utils.checkNotNull(position, "position");
        this.position = position;
        return this;
    }

    /**
     * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
     */
    public Feedback withPayload(String payload) {
        Utils.checkNotNull(payload, "payload");
        this.payload = Optional.ofNullable(payload);
        return this;
    }

    /**
     * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
     */
    public Feedback withPayload(Optional<String> payload) {
        Utils.checkNotNull(payload, "payload");
        this.payload = payload;
        return this;
    }

    public Feedback withSessionInfo(SessionInfo sessionInfo) {
        Utils.checkNotNull(sessionInfo, "sessionInfo");
        this.sessionInfo = Optional.ofNullable(sessionInfo);
        return this;
    }

    public Feedback withSessionInfo(Optional<? extends SessionInfo> sessionInfo) {
        Utils.checkNotNull(sessionInfo, "sessionInfo");
        this.sessionInfo = sessionInfo;
        return this;
    }

    /**
     * The ISO 8601 timestamp when the event occured.
     */
    public Feedback withTimestamp(OffsetDateTime timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = Optional.ofNullable(timestamp);
        return this;
    }

    /**
     * The ISO 8601 timestamp when the event occured.
     */
    public Feedback withTimestamp(Optional<OffsetDateTime> timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = timestamp;
        return this;
    }

    public Feedback withUser(User user) {
        Utils.checkNotNull(user, "user");
        this.user = Optional.ofNullable(user);
        return this;
    }

    public Feedback withUser(Optional<? extends User> user) {
        Utils.checkNotNull(user, "user");
        this.user = user;
        return this;
    }

    /**
     * The path the client was at when the feedback event triggered.
     */
    public Feedback withPathname(String pathname) {
        Utils.checkNotNull(pathname, "pathname");
        this.pathname = Optional.ofNullable(pathname);
        return this;
    }

    /**
     * The path the client was at when the feedback event triggered.
     */
    public Feedback withPathname(Optional<String> pathname) {
        Utils.checkNotNull(pathname, "pathname");
        this.pathname = pathname;
        return this;
    }

    /**
     * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
     */
    public Feedback withChannels(List<FeedbackChannel> channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = Optional.ofNullable(channels);
        return this;
    }

    /**
     * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
     */
    public Feedback withChannels(Optional<? extends List<FeedbackChannel>> channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = channels;
        return this;
    }

    /**
     * The URL the client was at when the feedback event triggered.
     */
    public Feedback withUrl(String url) {
        Utils.checkNotNull(url, "url");
        this.url = Optional.ofNullable(url);
        return this;
    }

    /**
     * The URL the client was at when the feedback event triggered.
     */
    public Feedback withUrl(Optional<String> url) {
        Utils.checkNotNull(url, "url");
        this.url = url;
        return this;
    }

    /**
     * The UI element tree associated with the event, if any.
     */
    public Feedback withUiTree(List<String> uiTree) {
        Utils.checkNotNull(uiTree, "uiTree");
        this.uiTree = Optional.ofNullable(uiTree);
        return this;
    }

    /**
     * The UI element tree associated with the event, if any.
     */
    public Feedback withUiTree(Optional<? extends List<String>> uiTree) {
        Utils.checkNotNull(uiTree, "uiTree");
        this.uiTree = uiTree;
        return this;
    }

    /**
     * The UI element associated with the event, if any.
     */
    public Feedback withUiElement(String uiElement) {
        Utils.checkNotNull(uiElement, "uiElement");
        this.uiElement = Optional.ofNullable(uiElement);
        return this;
    }

    /**
     * The UI element associated with the event, if any.
     */
    public Feedback withUiElement(Optional<String> uiElement) {
        Utils.checkNotNull(uiElement, "uiElement");
        this.uiElement = uiElement;
        return this;
    }

    public Feedback withManualFeedbackInfo(ManualFeedbackInfo manualFeedbackInfo) {
        Utils.checkNotNull(manualFeedbackInfo, "manualFeedbackInfo");
        this.manualFeedbackInfo = Optional.ofNullable(manualFeedbackInfo);
        return this;
    }

    public Feedback withManualFeedbackInfo(Optional<? extends ManualFeedbackInfo> manualFeedbackInfo) {
        Utils.checkNotNull(manualFeedbackInfo, "manualFeedbackInfo");
        this.manualFeedbackInfo = manualFeedbackInfo;
        return this;
    }

    public Feedback withSeenFeedbackInfo(SeenFeedbackInfo seenFeedbackInfo) {
        Utils.checkNotNull(seenFeedbackInfo, "seenFeedbackInfo");
        this.seenFeedbackInfo = Optional.ofNullable(seenFeedbackInfo);
        return this;
    }

    public Feedback withSeenFeedbackInfo(Optional<? extends SeenFeedbackInfo> seenFeedbackInfo) {
        Utils.checkNotNull(seenFeedbackInfo, "seenFeedbackInfo");
        this.seenFeedbackInfo = seenFeedbackInfo;
        return this;
    }

    public Feedback withUserViewInfo(UserViewInfo userViewInfo) {
        Utils.checkNotNull(userViewInfo, "userViewInfo");
        this.userViewInfo = Optional.ofNullable(userViewInfo);
        return this;
    }

    public Feedback withUserViewInfo(Optional<? extends UserViewInfo> userViewInfo) {
        Utils.checkNotNull(userViewInfo, "userViewInfo");
        this.userViewInfo = userViewInfo;
        return this;
    }

    public Feedback withWorkflowFeedbackInfo(WorkflowFeedbackInfo workflowFeedbackInfo) {
        Utils.checkNotNull(workflowFeedbackInfo, "workflowFeedbackInfo");
        this.workflowFeedbackInfo = Optional.ofNullable(workflowFeedbackInfo);
        return this;
    }

    public Feedback withWorkflowFeedbackInfo(Optional<? extends WorkflowFeedbackInfo> workflowFeedbackInfo) {
        Utils.checkNotNull(workflowFeedbackInfo, "workflowFeedbackInfo");
        this.workflowFeedbackInfo = workflowFeedbackInfo;
        return this;
    }

    /**
     * The application ID of the client that sent the feedback event.
     */
    public Feedback withApplicationId(String applicationId) {
        Utils.checkNotNull(applicationId, "applicationId");
        this.applicationId = Optional.ofNullable(applicationId);
        return this;
    }

    /**
     * The application ID of the client that sent the feedback event.
     */
    public Feedback withApplicationId(Optional<String> applicationId) {
        Utils.checkNotNull(applicationId, "applicationId");
        this.applicationId = applicationId;
        return this;
    }

    /**
     * The agent ID of the client that sent the feedback event.
     */
    public Feedback withAgentId(String agentId) {
        Utils.checkNotNull(agentId, "agentId");
        this.agentId = Optional.ofNullable(agentId);
        return this;
    }

    /**
     * The agent ID of the client that sent the feedback event.
     */
    public Feedback withAgentId(Optional<String> agentId) {
        Utils.checkNotNull(agentId, "agentId");
        this.agentId = agentId;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Feedback other = (Feedback) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.category, other.category) &&
            Utils.enhancedDeepEquals(this.trackingTokens, other.trackingTokens) &&
            Utils.enhancedDeepEquals(this.event, other.event) &&
            Utils.enhancedDeepEquals(this.position, other.position) &&
            Utils.enhancedDeepEquals(this.payload, other.payload) &&
            Utils.enhancedDeepEquals(this.sessionInfo, other.sessionInfo) &&
            Utils.enhancedDeepEquals(this.timestamp, other.timestamp) &&
            Utils.enhancedDeepEquals(this.user, other.user) &&
            Utils.enhancedDeepEquals(this.pathname, other.pathname) &&
            Utils.enhancedDeepEquals(this.channels, other.channels) &&
            Utils.enhancedDeepEquals(this.url, other.url) &&
            Utils.enhancedDeepEquals(this.uiTree, other.uiTree) &&
            Utils.enhancedDeepEquals(this.uiElement, other.uiElement) &&
            Utils.enhancedDeepEquals(this.manualFeedbackInfo, other.manualFeedbackInfo) &&
            Utils.enhancedDeepEquals(this.seenFeedbackInfo, other.seenFeedbackInfo) &&
            Utils.enhancedDeepEquals(this.userViewInfo, other.userViewInfo) &&
            Utils.enhancedDeepEquals(this.workflowFeedbackInfo, other.workflowFeedbackInfo) &&
            Utils.enhancedDeepEquals(this.applicationId, other.applicationId) &&
            Utils.enhancedDeepEquals(this.agentId, other.agentId);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id,
            category,
            trackingTokens,
            event,
            position,
            payload,
            sessionInfo,
            timestamp,
            user,
            pathname,
            channels,
            url,
            uiTree,
            uiElement,
            manualFeedbackInfo,
            seenFeedbackInfo,
            userViewInfo,
            workflowFeedbackInfo,
            applicationId,
            agentId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Feedback.class,
                "id", id,
                "category", category,
                "trackingTokens", trackingTokens,
                "event", event,
                "position", position,
                "payload", payload,
                "sessionInfo", sessionInfo,
                "timestamp", timestamp,
                "user", user,
                "pathname", pathname,
                "channels", channels,
                "url", url,
                "uiTree", uiTree,
                "uiElement", uiElement,
                "manualFeedbackInfo", manualFeedbackInfo,
                "seenFeedbackInfo", seenFeedbackInfo,
                "userViewInfo", userViewInfo,
                "workflowFeedbackInfo", workflowFeedbackInfo,
                "applicationId", applicationId,
                "agentId", agentId);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        private Optional<? extends FeedbackCategory> category = Optional.empty();
 
        private List<String> trackingTokens;
 
        private Event event;
 
        private Optional<Long> position = Optional.empty();
 
        private Optional<String> payload = Optional.empty();
 
        private Optional<? extends SessionInfo> sessionInfo = Optional.empty();
 
        private Optional<OffsetDateTime> timestamp = Optional.empty();
 
        private Optional<? extends User> user = Optional.empty();
 
        private Optional<String> pathname = Optional.empty();
 
        private Optional<? extends List<FeedbackChannel>> channels = Optional.empty();
 
        private Optional<String> url = Optional.empty();
 
        private Optional<? extends List<String>> uiTree = Optional.empty();
 
        private Optional<String> uiElement = Optional.empty();
 
        private Optional<? extends ManualFeedbackInfo> manualFeedbackInfo = Optional.empty();
 
        private Optional<? extends SeenFeedbackInfo> seenFeedbackInfo = Optional.empty();
 
        private Optional<? extends UserViewInfo> userViewInfo = Optional.empty();
 
        private Optional<? extends WorkflowFeedbackInfo> workflowFeedbackInfo = Optional.empty();
 
        private Optional<String> applicationId = Optional.empty();
 
        private Optional<String> agentId = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
         */
        public Builder category(FeedbackCategory category) {
            Utils.checkNotNull(category, "category");
            this.category = Optional.ofNullable(category);
            return this;
        }

        /**
         * The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
         */
        public Builder category(Optional<? extends FeedbackCategory> category) {
            Utils.checkNotNull(category, "category");
            this.category = category;
            return this;
        }

        /**
         * A list of server-generated trackingTokens to which this event applies.
         */
        public Builder trackingTokens(List<String> trackingTokens) {
            Utils.checkNotNull(trackingTokens, "trackingTokens");
            this.trackingTokens = trackingTokens;
            return this;
        }

        /**
         * The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
         */
        public Builder event(Event event) {
            Utils.checkNotNull(event, "event");
            this.event = event;
            return this;
        }

        /**
         * Position of the element in the case that the client controls order (such as feed and autocomplete).
         */
        public Builder position(long position) {
            Utils.checkNotNull(position, "position");
            this.position = Optional.ofNullable(position);
            return this;
        }

        /**
         * Position of the element in the case that the client controls order (such as feed and autocomplete).
         */
        public Builder position(Optional<Long> position) {
            Utils.checkNotNull(position, "position");
            this.position = position;
            return this;
        }

        /**
         * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
         */
        public Builder payload(String payload) {
            Utils.checkNotNull(payload, "payload");
            this.payload = Optional.ofNullable(payload);
            return this;
        }

        /**
         * For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
         */
        public Builder payload(Optional<String> payload) {
            Utils.checkNotNull(payload, "payload");
            this.payload = payload;
            return this;
        }

        public Builder sessionInfo(SessionInfo sessionInfo) {
            Utils.checkNotNull(sessionInfo, "sessionInfo");
            this.sessionInfo = Optional.ofNullable(sessionInfo);
            return this;
        }

        public Builder sessionInfo(Optional<? extends SessionInfo> sessionInfo) {
            Utils.checkNotNull(sessionInfo, "sessionInfo");
            this.sessionInfo = sessionInfo;
            return this;
        }

        /**
         * The ISO 8601 timestamp when the event occured.
         */
        public Builder timestamp(OffsetDateTime timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = Optional.ofNullable(timestamp);
            return this;
        }

        /**
         * The ISO 8601 timestamp when the event occured.
         */
        public Builder timestamp(Optional<OffsetDateTime> timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = timestamp;
            return this;
        }

        public Builder user(User user) {
            Utils.checkNotNull(user, "user");
            this.user = Optional.ofNullable(user);
            return this;
        }

        public Builder user(Optional<? extends User> user) {
            Utils.checkNotNull(user, "user");
            this.user = user;
            return this;
        }

        /**
         * The path the client was at when the feedback event triggered.
         */
        public Builder pathname(String pathname) {
            Utils.checkNotNull(pathname, "pathname");
            this.pathname = Optional.ofNullable(pathname);
            return this;
        }

        /**
         * The path the client was at when the feedback event triggered.
         */
        public Builder pathname(Optional<String> pathname) {
            Utils.checkNotNull(pathname, "pathname");
            this.pathname = pathname;
            return this;
        }

        /**
         * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
         */
        public Builder channels(List<FeedbackChannel> channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = Optional.ofNullable(channels);
            return this;
        }

        /**
         * Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
         */
        public Builder channels(Optional<? extends List<FeedbackChannel>> channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = channels;
            return this;
        }

        /**
         * The URL the client was at when the feedback event triggered.
         */
        public Builder url(String url) {
            Utils.checkNotNull(url, "url");
            this.url = Optional.ofNullable(url);
            return this;
        }

        /**
         * The URL the client was at when the feedback event triggered.
         */
        public Builder url(Optional<String> url) {
            Utils.checkNotNull(url, "url");
            this.url = url;
            return this;
        }

        /**
         * The UI element tree associated with the event, if any.
         */
        public Builder uiTree(List<String> uiTree) {
            Utils.checkNotNull(uiTree, "uiTree");
            this.uiTree = Optional.ofNullable(uiTree);
            return this;
        }

        /**
         * The UI element tree associated with the event, if any.
         */
        public Builder uiTree(Optional<? extends List<String>> uiTree) {
            Utils.checkNotNull(uiTree, "uiTree");
            this.uiTree = uiTree;
            return this;
        }

        /**
         * The UI element associated with the event, if any.
         */
        public Builder uiElement(String uiElement) {
            Utils.checkNotNull(uiElement, "uiElement");
            this.uiElement = Optional.ofNullable(uiElement);
            return this;
        }

        /**
         * The UI element associated with the event, if any.
         */
        public Builder uiElement(Optional<String> uiElement) {
            Utils.checkNotNull(uiElement, "uiElement");
            this.uiElement = uiElement;
            return this;
        }

        public Builder manualFeedbackInfo(ManualFeedbackInfo manualFeedbackInfo) {
            Utils.checkNotNull(manualFeedbackInfo, "manualFeedbackInfo");
            this.manualFeedbackInfo = Optional.ofNullable(manualFeedbackInfo);
            return this;
        }

        public Builder manualFeedbackInfo(Optional<? extends ManualFeedbackInfo> manualFeedbackInfo) {
            Utils.checkNotNull(manualFeedbackInfo, "manualFeedbackInfo");
            this.manualFeedbackInfo = manualFeedbackInfo;
            return this;
        }

        public Builder seenFeedbackInfo(SeenFeedbackInfo seenFeedbackInfo) {
            Utils.checkNotNull(seenFeedbackInfo, "seenFeedbackInfo");
            this.seenFeedbackInfo = Optional.ofNullable(seenFeedbackInfo);
            return this;
        }

        public Builder seenFeedbackInfo(Optional<? extends SeenFeedbackInfo> seenFeedbackInfo) {
            Utils.checkNotNull(seenFeedbackInfo, "seenFeedbackInfo");
            this.seenFeedbackInfo = seenFeedbackInfo;
            return this;
        }

        public Builder userViewInfo(UserViewInfo userViewInfo) {
            Utils.checkNotNull(userViewInfo, "userViewInfo");
            this.userViewInfo = Optional.ofNullable(userViewInfo);
            return this;
        }

        public Builder userViewInfo(Optional<? extends UserViewInfo> userViewInfo) {
            Utils.checkNotNull(userViewInfo, "userViewInfo");
            this.userViewInfo = userViewInfo;
            return this;
        }

        public Builder workflowFeedbackInfo(WorkflowFeedbackInfo workflowFeedbackInfo) {
            Utils.checkNotNull(workflowFeedbackInfo, "workflowFeedbackInfo");
            this.workflowFeedbackInfo = Optional.ofNullable(workflowFeedbackInfo);
            return this;
        }

        public Builder workflowFeedbackInfo(Optional<? extends WorkflowFeedbackInfo> workflowFeedbackInfo) {
            Utils.checkNotNull(workflowFeedbackInfo, "workflowFeedbackInfo");
            this.workflowFeedbackInfo = workflowFeedbackInfo;
            return this;
        }

        /**
         * The application ID of the client that sent the feedback event.
         */
        public Builder applicationId(String applicationId) {
            Utils.checkNotNull(applicationId, "applicationId");
            this.applicationId = Optional.ofNullable(applicationId);
            return this;
        }

        /**
         * The application ID of the client that sent the feedback event.
         */
        public Builder applicationId(Optional<String> applicationId) {
            Utils.checkNotNull(applicationId, "applicationId");
            this.applicationId = applicationId;
            return this;
        }

        /**
         * The agent ID of the client that sent the feedback event.
         */
        public Builder agentId(String agentId) {
            Utils.checkNotNull(agentId, "agentId");
            this.agentId = Optional.ofNullable(agentId);
            return this;
        }

        /**
         * The agent ID of the client that sent the feedback event.
         */
        public Builder agentId(Optional<String> agentId) {
            Utils.checkNotNull(agentId, "agentId");
            this.agentId = agentId;
            return this;
        }
        
        public Feedback build() {
            return new Feedback(
                id,
                category,
                trackingTokens,
                event,
                position,
                payload,
                sessionInfo,
                timestamp,
                user,
                pathname,
                channels,
                url,
                uiTree,
                uiElement,
                manualFeedbackInfo,
                seenFeedbackInfo,
                userViewInfo,
                workflowFeedbackInfo,
                applicationId,
                agentId);
        }
    }
}
