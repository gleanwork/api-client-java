/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class FacetResult {

    /**
     * The source of this facet (e.g. container_name, type, last_updated_at).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceName")
    private Optional<String> sourceName;

    /**
     * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("operatorName")
    private Optional<String> operatorName;

    /**
     * A list of unique buckets that exist within this result set.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("buckets")
    private Optional<? extends List<FacetBucket>> buckets;

    /**
     * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasMoreBuckets")
    private Optional<Boolean> hasMoreBuckets;

    /**
     * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("groupName")
    private Optional<String> groupName;

    @JsonCreator
    public FacetResult(
            @JsonProperty("sourceName") Optional<String> sourceName,
            @JsonProperty("operatorName") Optional<String> operatorName,
            @JsonProperty("buckets") Optional<? extends List<FacetBucket>> buckets,
            @JsonProperty("hasMoreBuckets") Optional<Boolean> hasMoreBuckets,
            @JsonProperty("groupName") Optional<String> groupName) {
        Utils.checkNotNull(sourceName, "sourceName");
        Utils.checkNotNull(operatorName, "operatorName");
        Utils.checkNotNull(buckets, "buckets");
        Utils.checkNotNull(hasMoreBuckets, "hasMoreBuckets");
        Utils.checkNotNull(groupName, "groupName");
        this.sourceName = sourceName;
        this.operatorName = operatorName;
        this.buckets = buckets;
        this.hasMoreBuckets = hasMoreBuckets;
        this.groupName = groupName;
    }
    
    public FacetResult() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The source of this facet (e.g. container_name, type, last_updated_at).
     */
    @JsonIgnore
    public Optional<String> sourceName() {
        return sourceName;
    }

    /**
     * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
     */
    @JsonIgnore
    public Optional<String> operatorName() {
        return operatorName;
    }

    /**
     * A list of unique buckets that exist within this result set.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FacetBucket>> buckets() {
        return (Optional<List<FacetBucket>>) buckets;
    }

    /**
     * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
     */
    @JsonIgnore
    public Optional<Boolean> hasMoreBuckets() {
        return hasMoreBuckets;
    }

    /**
     * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
     */
    @JsonIgnore
    public Optional<String> groupName() {
        return groupName;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The source of this facet (e.g. container_name, type, last_updated_at).
     */
    public FacetResult withSourceName(String sourceName) {
        Utils.checkNotNull(sourceName, "sourceName");
        this.sourceName = Optional.ofNullable(sourceName);
        return this;
    }

    /**
     * The source of this facet (e.g. container_name, type, last_updated_at).
     */
    public FacetResult withSourceName(Optional<String> sourceName) {
        Utils.checkNotNull(sourceName, "sourceName");
        this.sourceName = sourceName;
        return this;
    }

    /**
     * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
     */
    public FacetResult withOperatorName(String operatorName) {
        Utils.checkNotNull(operatorName, "operatorName");
        this.operatorName = Optional.ofNullable(operatorName);
        return this;
    }

    /**
     * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
     */
    public FacetResult withOperatorName(Optional<String> operatorName) {
        Utils.checkNotNull(operatorName, "operatorName");
        this.operatorName = operatorName;
        return this;
    }

    /**
     * A list of unique buckets that exist within this result set.
     */
    public FacetResult withBuckets(List<FacetBucket> buckets) {
        Utils.checkNotNull(buckets, "buckets");
        this.buckets = Optional.ofNullable(buckets);
        return this;
    }

    /**
     * A list of unique buckets that exist within this result set.
     */
    public FacetResult withBuckets(Optional<? extends List<FacetBucket>> buckets) {
        Utils.checkNotNull(buckets, "buckets");
        this.buckets = buckets;
        return this;
    }

    /**
     * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
     */
    public FacetResult withHasMoreBuckets(boolean hasMoreBuckets) {
        Utils.checkNotNull(hasMoreBuckets, "hasMoreBuckets");
        this.hasMoreBuckets = Optional.ofNullable(hasMoreBuckets);
        return this;
    }

    /**
     * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
     */
    public FacetResult withHasMoreBuckets(Optional<Boolean> hasMoreBuckets) {
        Utils.checkNotNull(hasMoreBuckets, "hasMoreBuckets");
        this.hasMoreBuckets = hasMoreBuckets;
        return this;
    }

    /**
     * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
     */
    public FacetResult withGroupName(String groupName) {
        Utils.checkNotNull(groupName, "groupName");
        this.groupName = Optional.ofNullable(groupName);
        return this;
    }

    /**
     * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
     */
    public FacetResult withGroupName(Optional<String> groupName) {
        Utils.checkNotNull(groupName, "groupName");
        this.groupName = groupName;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FacetResult other = (FacetResult) o;
        return 
            Objects.deepEquals(this.sourceName, other.sourceName) &&
            Objects.deepEquals(this.operatorName, other.operatorName) &&
            Objects.deepEquals(this.buckets, other.buckets) &&
            Objects.deepEquals(this.hasMoreBuckets, other.hasMoreBuckets) &&
            Objects.deepEquals(this.groupName, other.groupName);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            sourceName,
            operatorName,
            buckets,
            hasMoreBuckets,
            groupName);
    }
    
    @Override
    public String toString() {
        return Utils.toString(FacetResult.class,
                "sourceName", sourceName,
                "operatorName", operatorName,
                "buckets", buckets,
                "hasMoreBuckets", hasMoreBuckets,
                "groupName", groupName);
    }
    
    public final static class Builder {
 
        private Optional<String> sourceName = Optional.empty();
 
        private Optional<String> operatorName = Optional.empty();
 
        private Optional<? extends List<FacetBucket>> buckets = Optional.empty();
 
        private Optional<Boolean> hasMoreBuckets = Optional.empty();
 
        private Optional<String> groupName = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The source of this facet (e.g. container_name, type, last_updated_at).
         */
        public Builder sourceName(String sourceName) {
            Utils.checkNotNull(sourceName, "sourceName");
            this.sourceName = Optional.ofNullable(sourceName);
            return this;
        }

        /**
         * The source of this facet (e.g. container_name, type, last_updated_at).
         */
        public Builder sourceName(Optional<String> sourceName) {
            Utils.checkNotNull(sourceName, "sourceName");
            this.sourceName = sourceName;
            return this;
        }

        /**
         * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
         */
        public Builder operatorName(String operatorName) {
            Utils.checkNotNull(operatorName, "operatorName");
            this.operatorName = Optional.ofNullable(operatorName);
            return this;
        }

        /**
         * How to display this facet. Currently supportes 'SelectSingle' and 'SelectMultiple'.
         */
        public Builder operatorName(Optional<String> operatorName) {
            Utils.checkNotNull(operatorName, "operatorName");
            this.operatorName = operatorName;
            return this;
        }

        /**
         * A list of unique buckets that exist within this result set.
         */
        public Builder buckets(List<FacetBucket> buckets) {
            Utils.checkNotNull(buckets, "buckets");
            this.buckets = Optional.ofNullable(buckets);
            return this;
        }

        /**
         * A list of unique buckets that exist within this result set.
         */
        public Builder buckets(Optional<? extends List<FacetBucket>> buckets) {
            Utils.checkNotNull(buckets, "buckets");
            this.buckets = buckets;
            return this;
        }

        /**
         * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
         */
        public Builder hasMoreBuckets(boolean hasMoreBuckets) {
            Utils.checkNotNull(hasMoreBuckets, "hasMoreBuckets");
            this.hasMoreBuckets = Optional.ofNullable(hasMoreBuckets);
            return this;
        }

        /**
         * Returns true if more buckets exist than those returned. Additional buckets can be retrieve by requesting again with a higher facetBucketSize.
         */
        public Builder hasMoreBuckets(Optional<Boolean> hasMoreBuckets) {
            Utils.checkNotNull(hasMoreBuckets, "hasMoreBuckets");
            this.hasMoreBuckets = hasMoreBuckets;
            return this;
        }

        /**
         * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
         */
        public Builder groupName(String groupName) {
            Utils.checkNotNull(groupName, "groupName");
            this.groupName = Optional.ofNullable(groupName);
            return this;
        }

        /**
         * For most facets this will be the empty string, meaning the facet is high-level and applies to all documents for the datasource. When non-empty, this is used to group facets together (i.e. group facets for each doctype for a certain datasource)
         */
        public Builder groupName(Optional<String> groupName) {
            Utils.checkNotNull(groupName, "groupName");
            this.groupName = groupName;
            return this;
        }
        
        public FacetResult build() {
            return new FacetResult(
                sourceName,
                operatorName,
                buckets,
                hasMoreBuckets,
                groupName);
        }
    }
}
