/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class DocumentMetadata {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasource")
    private Optional<String> datasource;

    /**
     * The datasource instance from which the document was extracted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasourceInstance")
    private Optional<String> datasourceInstance;

    /**
     * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("objectType")
    private Optional<String> objectType;

    /**
     * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("container")
    private Optional<String> container;

    /**
     * The Glean Document ID of the container. Uniquely identifies the container.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("containerId")
    private Optional<String> containerId;

    /**
     * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("superContainerId")
    private Optional<String> superContainerId;

    /**
     * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentId")
    private Optional<String> parentId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mimeType")
    private Optional<String> mimeType;

    /**
     * The index-wide unique identifier.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("documentId")
    private Optional<String> documentId;

    /**
     * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("loggingId")
    private Optional<String> loggingId;

    /**
     * Hash of the Glean Document ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("documentIdHash")
    private Optional<String> documentIdHash;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createTime")
    private Optional<OffsetDateTime> createTime;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updateTime")
    private Optional<OffsetDateTime> updateTime;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("author")
    private Optional<? extends Person> author;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("owner")
    private Optional<? extends Person> owner;

    /**
     * A list of people mentioned in the document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mentionedPeople")
    private Optional<? extends List<Person>> mentionedPeople;

    /**
     * The level of visibility of the document as understood by our system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("visibility")
    private Optional<? extends DocumentVisibility> visibility;

    /**
     * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("components")
    private Optional<? extends List<String>> components;

    /**
     * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusCategory")
    private Optional<String> statusCategory;

    /**
     * A list of stars associated with this result.  "Pin" is an older name.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pins")
    private Optional<? extends List<PinDocument>> pins;

    /**
     * The document priority. Interpretation is datasource specific.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("priority")
    private Optional<String> priority;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("assignedTo")
    private Optional<? extends Person> assignedTo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedBy")
    private Optional<? extends Person> updatedBy;

    /**
     * A list of tags for the document. Interpretation is datasource specific.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("labels")
    private Optional<? extends List<String>> labels;

    /**
     * A list of collections that the document belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("collections")
    private Optional<? extends List<Collection>> collections;

    /**
     * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasourceId")
    private Optional<String> datasourceId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interactions")
    private Optional<? extends DocumentInteractions> interactions;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("verification")
    private Optional<? extends Verification> verification;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewerInfo")
    private Optional<? extends ViewerInfo> viewerInfo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("permissions")
    private Optional<? extends ObjectPermissions> permissions;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("visitCount")
    private Optional<? extends CountInfo> visitCount;

    /**
     * A list of shortcuts of which destination URL is for the document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shortcuts")
    private Optional<? extends List<Shortcut>> shortcuts;

    /**
     * For file datasources like onedrive/github etc this has the path to the file
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("path")
    private Optional<String> path;

    /**
     * Custom fields specific to individual datasources
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customData")
    private Optional<? extends Map<String, CustomDataValue>> customData;

    /**
     * The document's document_category(.proto).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("documentCategory")
    private Optional<String> documentCategory;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contactPerson")
    private Optional<? extends Person> contactPerson;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumbnail")
    private Optional<? extends Thumbnail> thumbnail;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indexStatus")
    private Optional<? extends IndexStatus> indexStatus;

    /**
     * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ancestors")
    private Optional<? extends List<Document>> ancestors;

    @JsonCreator
    public DocumentMetadata(
            @JsonProperty("datasource") Optional<String> datasource,
            @JsonProperty("datasourceInstance") Optional<String> datasourceInstance,
            @JsonProperty("objectType") Optional<String> objectType,
            @JsonProperty("container") Optional<String> container,
            @JsonProperty("containerId") Optional<String> containerId,
            @JsonProperty("superContainerId") Optional<String> superContainerId,
            @JsonProperty("parentId") Optional<String> parentId,
            @JsonProperty("mimeType") Optional<String> mimeType,
            @JsonProperty("documentId") Optional<String> documentId,
            @JsonProperty("loggingId") Optional<String> loggingId,
            @JsonProperty("documentIdHash") Optional<String> documentIdHash,
            @JsonProperty("createTime") Optional<OffsetDateTime> createTime,
            @JsonProperty("updateTime") Optional<OffsetDateTime> updateTime,
            @JsonProperty("author") Optional<? extends Person> author,
            @JsonProperty("owner") Optional<? extends Person> owner,
            @JsonProperty("mentionedPeople") Optional<? extends List<Person>> mentionedPeople,
            @JsonProperty("visibility") Optional<? extends DocumentVisibility> visibility,
            @JsonProperty("components") Optional<? extends List<String>> components,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("statusCategory") Optional<String> statusCategory,
            @JsonProperty("pins") Optional<? extends List<PinDocument>> pins,
            @JsonProperty("priority") Optional<String> priority,
            @JsonProperty("assignedTo") Optional<? extends Person> assignedTo,
            @JsonProperty("updatedBy") Optional<? extends Person> updatedBy,
            @JsonProperty("labels") Optional<? extends List<String>> labels,
            @JsonProperty("collections") Optional<? extends List<Collection>> collections,
            @JsonProperty("datasourceId") Optional<String> datasourceId,
            @JsonProperty("interactions") Optional<? extends DocumentInteractions> interactions,
            @JsonProperty("verification") Optional<? extends Verification> verification,
            @JsonProperty("viewerInfo") Optional<? extends ViewerInfo> viewerInfo,
            @JsonProperty("permissions") Optional<? extends ObjectPermissions> permissions,
            @JsonProperty("visitCount") Optional<? extends CountInfo> visitCount,
            @JsonProperty("shortcuts") Optional<? extends List<Shortcut>> shortcuts,
            @JsonProperty("path") Optional<String> path,
            @JsonProperty("customData") Optional<? extends Map<String, CustomDataValue>> customData,
            @JsonProperty("documentCategory") Optional<String> documentCategory,
            @JsonProperty("contactPerson") Optional<? extends Person> contactPerson,
            @JsonProperty("thumbnail") Optional<? extends Thumbnail> thumbnail,
            @JsonProperty("indexStatus") Optional<? extends IndexStatus> indexStatus,
            @JsonProperty("ancestors") Optional<? extends List<Document>> ancestors) {
        Utils.checkNotNull(datasource, "datasource");
        Utils.checkNotNull(datasourceInstance, "datasourceInstance");
        Utils.checkNotNull(objectType, "objectType");
        Utils.checkNotNull(container, "container");
        Utils.checkNotNull(containerId, "containerId");
        Utils.checkNotNull(superContainerId, "superContainerId");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(mimeType, "mimeType");
        Utils.checkNotNull(documentId, "documentId");
        Utils.checkNotNull(loggingId, "loggingId");
        Utils.checkNotNull(documentIdHash, "documentIdHash");
        Utils.checkNotNull(createTime, "createTime");
        Utils.checkNotNull(updateTime, "updateTime");
        Utils.checkNotNull(author, "author");
        Utils.checkNotNull(owner, "owner");
        Utils.checkNotNull(mentionedPeople, "mentionedPeople");
        Utils.checkNotNull(visibility, "visibility");
        Utils.checkNotNull(components, "components");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusCategory, "statusCategory");
        Utils.checkNotNull(pins, "pins");
        Utils.checkNotNull(priority, "priority");
        Utils.checkNotNull(assignedTo, "assignedTo");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(labels, "labels");
        Utils.checkNotNull(collections, "collections");
        Utils.checkNotNull(datasourceId, "datasourceId");
        Utils.checkNotNull(interactions, "interactions");
        Utils.checkNotNull(verification, "verification");
        Utils.checkNotNull(viewerInfo, "viewerInfo");
        Utils.checkNotNull(permissions, "permissions");
        Utils.checkNotNull(visitCount, "visitCount");
        Utils.checkNotNull(shortcuts, "shortcuts");
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(customData, "customData");
        Utils.checkNotNull(documentCategory, "documentCategory");
        Utils.checkNotNull(contactPerson, "contactPerson");
        Utils.checkNotNull(thumbnail, "thumbnail");
        Utils.checkNotNull(indexStatus, "indexStatus");
        Utils.checkNotNull(ancestors, "ancestors");
        this.datasource = datasource;
        this.datasourceInstance = datasourceInstance;
        this.objectType = objectType;
        this.container = container;
        this.containerId = containerId;
        this.superContainerId = superContainerId;
        this.parentId = parentId;
        this.mimeType = mimeType;
        this.documentId = documentId;
        this.loggingId = loggingId;
        this.documentIdHash = documentIdHash;
        this.createTime = createTime;
        this.updateTime = updateTime;
        this.author = author;
        this.owner = owner;
        this.mentionedPeople = mentionedPeople;
        this.visibility = visibility;
        this.components = components;
        this.status = status;
        this.statusCategory = statusCategory;
        this.pins = pins;
        this.priority = priority;
        this.assignedTo = assignedTo;
        this.updatedBy = updatedBy;
        this.labels = labels;
        this.collections = collections;
        this.datasourceId = datasourceId;
        this.interactions = interactions;
        this.verification = verification;
        this.viewerInfo = viewerInfo;
        this.permissions = permissions;
        this.visitCount = visitCount;
        this.shortcuts = shortcuts;
        this.path = path;
        this.customData = customData;
        this.documentCategory = documentCategory;
        this.contactPerson = contactPerson;
        this.thumbnail = thumbnail;
        this.indexStatus = indexStatus;
        this.ancestors = ancestors;
    }
    
    public DocumentMetadata() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<String> datasource() {
        return datasource;
    }

    /**
     * The datasource instance from which the document was extracted.
     */
    @JsonIgnore
    public Optional<String> datasourceInstance() {
        return datasourceInstance;
    }

    /**
     * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    @JsonIgnore
    public Optional<String> objectType() {
        return objectType;
    }

    /**
     * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
     */
    @JsonIgnore
    public Optional<String> container() {
        return container;
    }

    /**
     * The Glean Document ID of the container. Uniquely identifies the container.
     */
    @JsonIgnore
    public Optional<String> containerId() {
        return containerId;
    }

    /**
     * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
     */
    @JsonIgnore
    public Optional<String> superContainerId() {
        return superContainerId;
    }

    /**
     * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
     */
    @JsonIgnore
    public Optional<String> parentId() {
        return parentId;
    }

    @JsonIgnore
    public Optional<String> mimeType() {
        return mimeType;
    }

    /**
     * The index-wide unique identifier.
     */
    @JsonIgnore
    public Optional<String> documentId() {
        return documentId;
    }

    /**
     * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
     */
    @JsonIgnore
    public Optional<String> loggingId() {
        return loggingId;
    }

    /**
     * Hash of the Glean Document ID.
     */
    @JsonIgnore
    public Optional<String> documentIdHash() {
        return documentIdHash;
    }

    @JsonIgnore
    public Optional<OffsetDateTime> createTime() {
        return createTime;
    }

    @JsonIgnore
    public Optional<OffsetDateTime> updateTime() {
        return updateTime;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> author() {
        return (Optional<Person>) author;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> owner() {
        return (Optional<Person>) owner;
    }

    /**
     * A list of people mentioned in the document.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Person>> mentionedPeople() {
        return (Optional<List<Person>>) mentionedPeople;
    }

    /**
     * The level of visibility of the document as understood by our system.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DocumentVisibility> visibility() {
        return (Optional<DocumentVisibility>) visibility;
    }

    /**
     * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> components() {
        return (Optional<List<String>>) components;
    }

    /**
     * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
     */
    @JsonIgnore
    public Optional<String> statusCategory() {
        return statusCategory;
    }

    /**
     * A list of stars associated with this result.  "Pin" is an older name.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PinDocument>> pins() {
        return (Optional<List<PinDocument>>) pins;
    }

    /**
     * The document priority. Interpretation is datasource specific.
     */
    @JsonIgnore
    public Optional<String> priority() {
        return priority;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> assignedTo() {
        return (Optional<Person>) assignedTo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> updatedBy() {
        return (Optional<Person>) updatedBy;
    }

    /**
     * A list of tags for the document. Interpretation is datasource specific.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> labels() {
        return (Optional<List<String>>) labels;
    }

    /**
     * A list of collections that the document belongs to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Collection>> collections() {
        return (Optional<List<Collection>>) collections;
    }

    /**
     * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
     */
    @JsonIgnore
    public Optional<String> datasourceId() {
        return datasourceId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DocumentInteractions> interactions() {
        return (Optional<DocumentInteractions>) interactions;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Verification> verification() {
        return (Optional<Verification>) verification;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ViewerInfo> viewerInfo() {
        return (Optional<ViewerInfo>) viewerInfo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ObjectPermissions> permissions() {
        return (Optional<ObjectPermissions>) permissions;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CountInfo> visitCount() {
        return (Optional<CountInfo>) visitCount;
    }

    /**
     * A list of shortcuts of which destination URL is for the document.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Shortcut>> shortcuts() {
        return (Optional<List<Shortcut>>) shortcuts;
    }

    /**
     * For file datasources like onedrive/github etc this has the path to the file
     */
    @JsonIgnore
    public Optional<String> path() {
        return path;
    }

    /**
     * Custom fields specific to individual datasources
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, CustomDataValue>> customData() {
        return (Optional<Map<String, CustomDataValue>>) customData;
    }

    /**
     * The document's document_category(.proto).
     */
    @JsonIgnore
    public Optional<String> documentCategory() {
        return documentCategory;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> contactPerson() {
        return (Optional<Person>) contactPerson;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Thumbnail> thumbnail() {
        return (Optional<Thumbnail>) thumbnail;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<IndexStatus> indexStatus() {
        return (Optional<IndexStatus>) indexStatus;
    }

    /**
     * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Document>> ancestors() {
        return (Optional<List<Document>>) ancestors;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    public DocumentMetadata withDatasource(String datasource) {
        Utils.checkNotNull(datasource, "datasource");
        this.datasource = Optional.ofNullable(datasource);
        return this;
    }

    public DocumentMetadata withDatasource(Optional<String> datasource) {
        Utils.checkNotNull(datasource, "datasource");
        this.datasource = datasource;
        return this;
    }

    /**
     * The datasource instance from which the document was extracted.
     */
    public DocumentMetadata withDatasourceInstance(String datasourceInstance) {
        Utils.checkNotNull(datasourceInstance, "datasourceInstance");
        this.datasourceInstance = Optional.ofNullable(datasourceInstance);
        return this;
    }

    /**
     * The datasource instance from which the document was extracted.
     */
    public DocumentMetadata withDatasourceInstance(Optional<String> datasourceInstance) {
        Utils.checkNotNull(datasourceInstance, "datasourceInstance");
        this.datasourceInstance = datasourceInstance;
        return this;
    }

    /**
     * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    public DocumentMetadata withObjectType(String objectType) {
        Utils.checkNotNull(objectType, "objectType");
        this.objectType = Optional.ofNullable(objectType);
        return this;
    }

    /**
     * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    public DocumentMetadata withObjectType(Optional<String> objectType) {
        Utils.checkNotNull(objectType, "objectType");
        this.objectType = objectType;
        return this;
    }

    /**
     * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
     */
    public DocumentMetadata withContainer(String container) {
        Utils.checkNotNull(container, "container");
        this.container = Optional.ofNullable(container);
        return this;
    }

    /**
     * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
     */
    public DocumentMetadata withContainer(Optional<String> container) {
        Utils.checkNotNull(container, "container");
        this.container = container;
        return this;
    }

    /**
     * The Glean Document ID of the container. Uniquely identifies the container.
     */
    public DocumentMetadata withContainerId(String containerId) {
        Utils.checkNotNull(containerId, "containerId");
        this.containerId = Optional.ofNullable(containerId);
        return this;
    }

    /**
     * The Glean Document ID of the container. Uniquely identifies the container.
     */
    public DocumentMetadata withContainerId(Optional<String> containerId) {
        Utils.checkNotNull(containerId, "containerId");
        this.containerId = containerId;
        return this;
    }

    /**
     * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
     */
    public DocumentMetadata withSuperContainerId(String superContainerId) {
        Utils.checkNotNull(superContainerId, "superContainerId");
        this.superContainerId = Optional.ofNullable(superContainerId);
        return this;
    }

    /**
     * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
     */
    public DocumentMetadata withSuperContainerId(Optional<String> superContainerId) {
        Utils.checkNotNull(superContainerId, "superContainerId");
        this.superContainerId = superContainerId;
        return this;
    }

    /**
     * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
     */
    public DocumentMetadata withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }

    /**
     * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
     */
    public DocumentMetadata withParentId(Optional<String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    public DocumentMetadata withMimeType(String mimeType) {
        Utils.checkNotNull(mimeType, "mimeType");
        this.mimeType = Optional.ofNullable(mimeType);
        return this;
    }

    public DocumentMetadata withMimeType(Optional<String> mimeType) {
        Utils.checkNotNull(mimeType, "mimeType");
        this.mimeType = mimeType;
        return this;
    }

    /**
     * The index-wide unique identifier.
     */
    public DocumentMetadata withDocumentId(String documentId) {
        Utils.checkNotNull(documentId, "documentId");
        this.documentId = Optional.ofNullable(documentId);
        return this;
    }

    /**
     * The index-wide unique identifier.
     */
    public DocumentMetadata withDocumentId(Optional<String> documentId) {
        Utils.checkNotNull(documentId, "documentId");
        this.documentId = documentId;
        return this;
    }

    /**
     * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
     */
    public DocumentMetadata withLoggingId(String loggingId) {
        Utils.checkNotNull(loggingId, "loggingId");
        this.loggingId = Optional.ofNullable(loggingId);
        return this;
    }

    /**
     * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
     */
    public DocumentMetadata withLoggingId(Optional<String> loggingId) {
        Utils.checkNotNull(loggingId, "loggingId");
        this.loggingId = loggingId;
        return this;
    }

    /**
     * Hash of the Glean Document ID.
     */
    public DocumentMetadata withDocumentIdHash(String documentIdHash) {
        Utils.checkNotNull(documentIdHash, "documentIdHash");
        this.documentIdHash = Optional.ofNullable(documentIdHash);
        return this;
    }

    /**
     * Hash of the Glean Document ID.
     */
    public DocumentMetadata withDocumentIdHash(Optional<String> documentIdHash) {
        Utils.checkNotNull(documentIdHash, "documentIdHash");
        this.documentIdHash = documentIdHash;
        return this;
    }

    public DocumentMetadata withCreateTime(OffsetDateTime createTime) {
        Utils.checkNotNull(createTime, "createTime");
        this.createTime = Optional.ofNullable(createTime);
        return this;
    }

    public DocumentMetadata withCreateTime(Optional<OffsetDateTime> createTime) {
        Utils.checkNotNull(createTime, "createTime");
        this.createTime = createTime;
        return this;
    }

    public DocumentMetadata withUpdateTime(OffsetDateTime updateTime) {
        Utils.checkNotNull(updateTime, "updateTime");
        this.updateTime = Optional.ofNullable(updateTime);
        return this;
    }

    public DocumentMetadata withUpdateTime(Optional<OffsetDateTime> updateTime) {
        Utils.checkNotNull(updateTime, "updateTime");
        this.updateTime = updateTime;
        return this;
    }

    public DocumentMetadata withAuthor(Person author) {
        Utils.checkNotNull(author, "author");
        this.author = Optional.ofNullable(author);
        return this;
    }

    public DocumentMetadata withAuthor(Optional<? extends Person> author) {
        Utils.checkNotNull(author, "author");
        this.author = author;
        return this;
    }

    public DocumentMetadata withOwner(Person owner) {
        Utils.checkNotNull(owner, "owner");
        this.owner = Optional.ofNullable(owner);
        return this;
    }

    public DocumentMetadata withOwner(Optional<? extends Person> owner) {
        Utils.checkNotNull(owner, "owner");
        this.owner = owner;
        return this;
    }

    /**
     * A list of people mentioned in the document.
     */
    public DocumentMetadata withMentionedPeople(List<Person> mentionedPeople) {
        Utils.checkNotNull(mentionedPeople, "mentionedPeople");
        this.mentionedPeople = Optional.ofNullable(mentionedPeople);
        return this;
    }

    /**
     * A list of people mentioned in the document.
     */
    public DocumentMetadata withMentionedPeople(Optional<? extends List<Person>> mentionedPeople) {
        Utils.checkNotNull(mentionedPeople, "mentionedPeople");
        this.mentionedPeople = mentionedPeople;
        return this;
    }

    /**
     * The level of visibility of the document as understood by our system.
     */
    public DocumentMetadata withVisibility(DocumentVisibility visibility) {
        Utils.checkNotNull(visibility, "visibility");
        this.visibility = Optional.ofNullable(visibility);
        return this;
    }

    /**
     * The level of visibility of the document as understood by our system.
     */
    public DocumentMetadata withVisibility(Optional<? extends DocumentVisibility> visibility) {
        Utils.checkNotNull(visibility, "visibility");
        this.visibility = visibility;
        return this;
    }

    /**
     * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
     */
    public DocumentMetadata withComponents(List<String> components) {
        Utils.checkNotNull(components, "components");
        this.components = Optional.ofNullable(components);
        return this;
    }

    /**
     * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
     */
    public DocumentMetadata withComponents(Optional<? extends List<String>> components) {
        Utils.checkNotNull(components, "components");
        this.components = components;
        return this;
    }

    /**
     * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
     */
    public DocumentMetadata withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
     */
    public DocumentMetadata withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
     */
    public DocumentMetadata withStatusCategory(String statusCategory) {
        Utils.checkNotNull(statusCategory, "statusCategory");
        this.statusCategory = Optional.ofNullable(statusCategory);
        return this;
    }

    /**
     * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
     */
    public DocumentMetadata withStatusCategory(Optional<String> statusCategory) {
        Utils.checkNotNull(statusCategory, "statusCategory");
        this.statusCategory = statusCategory;
        return this;
    }

    /**
     * A list of stars associated with this result.  "Pin" is an older name.
     */
    public DocumentMetadata withPins(List<PinDocument> pins) {
        Utils.checkNotNull(pins, "pins");
        this.pins = Optional.ofNullable(pins);
        return this;
    }

    /**
     * A list of stars associated with this result.  "Pin" is an older name.
     */
    public DocumentMetadata withPins(Optional<? extends List<PinDocument>> pins) {
        Utils.checkNotNull(pins, "pins");
        this.pins = pins;
        return this;
    }

    /**
     * The document priority. Interpretation is datasource specific.
     */
    public DocumentMetadata withPriority(String priority) {
        Utils.checkNotNull(priority, "priority");
        this.priority = Optional.ofNullable(priority);
        return this;
    }

    /**
     * The document priority. Interpretation is datasource specific.
     */
    public DocumentMetadata withPriority(Optional<String> priority) {
        Utils.checkNotNull(priority, "priority");
        this.priority = priority;
        return this;
    }

    public DocumentMetadata withAssignedTo(Person assignedTo) {
        Utils.checkNotNull(assignedTo, "assignedTo");
        this.assignedTo = Optional.ofNullable(assignedTo);
        return this;
    }

    public DocumentMetadata withAssignedTo(Optional<? extends Person> assignedTo) {
        Utils.checkNotNull(assignedTo, "assignedTo");
        this.assignedTo = assignedTo;
        return this;
    }

    public DocumentMetadata withUpdatedBy(Person updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = Optional.ofNullable(updatedBy);
        return this;
    }

    public DocumentMetadata withUpdatedBy(Optional<? extends Person> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * A list of tags for the document. Interpretation is datasource specific.
     */
    public DocumentMetadata withLabels(List<String> labels) {
        Utils.checkNotNull(labels, "labels");
        this.labels = Optional.ofNullable(labels);
        return this;
    }

    /**
     * A list of tags for the document. Interpretation is datasource specific.
     */
    public DocumentMetadata withLabels(Optional<? extends List<String>> labels) {
        Utils.checkNotNull(labels, "labels");
        this.labels = labels;
        return this;
    }

    /**
     * A list of collections that the document belongs to.
     */
    public DocumentMetadata withCollections(List<Collection> collections) {
        Utils.checkNotNull(collections, "collections");
        this.collections = Optional.ofNullable(collections);
        return this;
    }

    /**
     * A list of collections that the document belongs to.
     */
    public DocumentMetadata withCollections(Optional<? extends List<Collection>> collections) {
        Utils.checkNotNull(collections, "collections");
        this.collections = collections;
        return this;
    }

    /**
     * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
     */
    public DocumentMetadata withDatasourceId(String datasourceId) {
        Utils.checkNotNull(datasourceId, "datasourceId");
        this.datasourceId = Optional.ofNullable(datasourceId);
        return this;
    }

    /**
     * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
     */
    public DocumentMetadata withDatasourceId(Optional<String> datasourceId) {
        Utils.checkNotNull(datasourceId, "datasourceId");
        this.datasourceId = datasourceId;
        return this;
    }

    public DocumentMetadata withInteractions(DocumentInteractions interactions) {
        Utils.checkNotNull(interactions, "interactions");
        this.interactions = Optional.ofNullable(interactions);
        return this;
    }

    public DocumentMetadata withInteractions(Optional<? extends DocumentInteractions> interactions) {
        Utils.checkNotNull(interactions, "interactions");
        this.interactions = interactions;
        return this;
    }

    public DocumentMetadata withVerification(Verification verification) {
        Utils.checkNotNull(verification, "verification");
        this.verification = Optional.ofNullable(verification);
        return this;
    }

    public DocumentMetadata withVerification(Optional<? extends Verification> verification) {
        Utils.checkNotNull(verification, "verification");
        this.verification = verification;
        return this;
    }

    public DocumentMetadata withViewerInfo(ViewerInfo viewerInfo) {
        Utils.checkNotNull(viewerInfo, "viewerInfo");
        this.viewerInfo = Optional.ofNullable(viewerInfo);
        return this;
    }

    public DocumentMetadata withViewerInfo(Optional<? extends ViewerInfo> viewerInfo) {
        Utils.checkNotNull(viewerInfo, "viewerInfo");
        this.viewerInfo = viewerInfo;
        return this;
    }

    public DocumentMetadata withPermissions(ObjectPermissions permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = Optional.ofNullable(permissions);
        return this;
    }

    public DocumentMetadata withPermissions(Optional<? extends ObjectPermissions> permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = permissions;
        return this;
    }

    public DocumentMetadata withVisitCount(CountInfo visitCount) {
        Utils.checkNotNull(visitCount, "visitCount");
        this.visitCount = Optional.ofNullable(visitCount);
        return this;
    }

    public DocumentMetadata withVisitCount(Optional<? extends CountInfo> visitCount) {
        Utils.checkNotNull(visitCount, "visitCount");
        this.visitCount = visitCount;
        return this;
    }

    /**
     * A list of shortcuts of which destination URL is for the document.
     */
    public DocumentMetadata withShortcuts(List<Shortcut> shortcuts) {
        Utils.checkNotNull(shortcuts, "shortcuts");
        this.shortcuts = Optional.ofNullable(shortcuts);
        return this;
    }

    /**
     * A list of shortcuts of which destination URL is for the document.
     */
    public DocumentMetadata withShortcuts(Optional<? extends List<Shortcut>> shortcuts) {
        Utils.checkNotNull(shortcuts, "shortcuts");
        this.shortcuts = shortcuts;
        return this;
    }

    /**
     * For file datasources like onedrive/github etc this has the path to the file
     */
    public DocumentMetadata withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = Optional.ofNullable(path);
        return this;
    }

    /**
     * For file datasources like onedrive/github etc this has the path to the file
     */
    public DocumentMetadata withPath(Optional<String> path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * Custom fields specific to individual datasources
     */
    public DocumentMetadata withCustomData(Map<String, CustomDataValue> customData) {
        Utils.checkNotNull(customData, "customData");
        this.customData = Optional.ofNullable(customData);
        return this;
    }

    /**
     * Custom fields specific to individual datasources
     */
    public DocumentMetadata withCustomData(Optional<? extends Map<String, CustomDataValue>> customData) {
        Utils.checkNotNull(customData, "customData");
        this.customData = customData;
        return this;
    }

    /**
     * The document's document_category(.proto).
     */
    public DocumentMetadata withDocumentCategory(String documentCategory) {
        Utils.checkNotNull(documentCategory, "documentCategory");
        this.documentCategory = Optional.ofNullable(documentCategory);
        return this;
    }

    /**
     * The document's document_category(.proto).
     */
    public DocumentMetadata withDocumentCategory(Optional<String> documentCategory) {
        Utils.checkNotNull(documentCategory, "documentCategory");
        this.documentCategory = documentCategory;
        return this;
    }

    public DocumentMetadata withContactPerson(Person contactPerson) {
        Utils.checkNotNull(contactPerson, "contactPerson");
        this.contactPerson = Optional.ofNullable(contactPerson);
        return this;
    }

    public DocumentMetadata withContactPerson(Optional<? extends Person> contactPerson) {
        Utils.checkNotNull(contactPerson, "contactPerson");
        this.contactPerson = contactPerson;
        return this;
    }

    public DocumentMetadata withThumbnail(Thumbnail thumbnail) {
        Utils.checkNotNull(thumbnail, "thumbnail");
        this.thumbnail = Optional.ofNullable(thumbnail);
        return this;
    }

    public DocumentMetadata withThumbnail(Optional<? extends Thumbnail> thumbnail) {
        Utils.checkNotNull(thumbnail, "thumbnail");
        this.thumbnail = thumbnail;
        return this;
    }

    public DocumentMetadata withIndexStatus(IndexStatus indexStatus) {
        Utils.checkNotNull(indexStatus, "indexStatus");
        this.indexStatus = Optional.ofNullable(indexStatus);
        return this;
    }

    public DocumentMetadata withIndexStatus(Optional<? extends IndexStatus> indexStatus) {
        Utils.checkNotNull(indexStatus, "indexStatus");
        this.indexStatus = indexStatus;
        return this;
    }

    /**
     * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
     */
    public DocumentMetadata withAncestors(List<Document> ancestors) {
        Utils.checkNotNull(ancestors, "ancestors");
        this.ancestors = Optional.ofNullable(ancestors);
        return this;
    }

    /**
     * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
     */
    public DocumentMetadata withAncestors(Optional<? extends List<Document>> ancestors) {
        Utils.checkNotNull(ancestors, "ancestors");
        this.ancestors = ancestors;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DocumentMetadata other = (DocumentMetadata) o;
        return 
            Utils.enhancedDeepEquals(this.datasource, other.datasource) &&
            Utils.enhancedDeepEquals(this.datasourceInstance, other.datasourceInstance) &&
            Utils.enhancedDeepEquals(this.objectType, other.objectType) &&
            Utils.enhancedDeepEquals(this.container, other.container) &&
            Utils.enhancedDeepEquals(this.containerId, other.containerId) &&
            Utils.enhancedDeepEquals(this.superContainerId, other.superContainerId) &&
            Utils.enhancedDeepEquals(this.parentId, other.parentId) &&
            Utils.enhancedDeepEquals(this.mimeType, other.mimeType) &&
            Utils.enhancedDeepEquals(this.documentId, other.documentId) &&
            Utils.enhancedDeepEquals(this.loggingId, other.loggingId) &&
            Utils.enhancedDeepEquals(this.documentIdHash, other.documentIdHash) &&
            Utils.enhancedDeepEquals(this.createTime, other.createTime) &&
            Utils.enhancedDeepEquals(this.updateTime, other.updateTime) &&
            Utils.enhancedDeepEquals(this.author, other.author) &&
            Utils.enhancedDeepEquals(this.owner, other.owner) &&
            Utils.enhancedDeepEquals(this.mentionedPeople, other.mentionedPeople) &&
            Utils.enhancedDeepEquals(this.visibility, other.visibility) &&
            Utils.enhancedDeepEquals(this.components, other.components) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.statusCategory, other.statusCategory) &&
            Utils.enhancedDeepEquals(this.pins, other.pins) &&
            Utils.enhancedDeepEquals(this.priority, other.priority) &&
            Utils.enhancedDeepEquals(this.assignedTo, other.assignedTo) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.labels, other.labels) &&
            Utils.enhancedDeepEquals(this.collections, other.collections) &&
            Utils.enhancedDeepEquals(this.datasourceId, other.datasourceId) &&
            Utils.enhancedDeepEquals(this.interactions, other.interactions) &&
            Utils.enhancedDeepEquals(this.verification, other.verification) &&
            Utils.enhancedDeepEquals(this.viewerInfo, other.viewerInfo) &&
            Utils.enhancedDeepEquals(this.permissions, other.permissions) &&
            Utils.enhancedDeepEquals(this.visitCount, other.visitCount) &&
            Utils.enhancedDeepEquals(this.shortcuts, other.shortcuts) &&
            Utils.enhancedDeepEquals(this.path, other.path) &&
            Utils.enhancedDeepEquals(this.customData, other.customData) &&
            Utils.enhancedDeepEquals(this.documentCategory, other.documentCategory) &&
            Utils.enhancedDeepEquals(this.contactPerson, other.contactPerson) &&
            Utils.enhancedDeepEquals(this.thumbnail, other.thumbnail) &&
            Utils.enhancedDeepEquals(this.indexStatus, other.indexStatus) &&
            Utils.enhancedDeepEquals(this.ancestors, other.ancestors);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            datasource,
            datasourceInstance,
            objectType,
            container,
            containerId,
            superContainerId,
            parentId,
            mimeType,
            documentId,
            loggingId,
            documentIdHash,
            createTime,
            updateTime,
            author,
            owner,
            mentionedPeople,
            visibility,
            components,
            status,
            statusCategory,
            pins,
            priority,
            assignedTo,
            updatedBy,
            labels,
            collections,
            datasourceId,
            interactions,
            verification,
            viewerInfo,
            permissions,
            visitCount,
            shortcuts,
            path,
            customData,
            documentCategory,
            contactPerson,
            thumbnail,
            indexStatus,
            ancestors);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DocumentMetadata.class,
                "datasource", datasource,
                "datasourceInstance", datasourceInstance,
                "objectType", objectType,
                "container", container,
                "containerId", containerId,
                "superContainerId", superContainerId,
                "parentId", parentId,
                "mimeType", mimeType,
                "documentId", documentId,
                "loggingId", loggingId,
                "documentIdHash", documentIdHash,
                "createTime", createTime,
                "updateTime", updateTime,
                "author", author,
                "owner", owner,
                "mentionedPeople", mentionedPeople,
                "visibility", visibility,
                "components", components,
                "status", status,
                "statusCategory", statusCategory,
                "pins", pins,
                "priority", priority,
                "assignedTo", assignedTo,
                "updatedBy", updatedBy,
                "labels", labels,
                "collections", collections,
                "datasourceId", datasourceId,
                "interactions", interactions,
                "verification", verification,
                "viewerInfo", viewerInfo,
                "permissions", permissions,
                "visitCount", visitCount,
                "shortcuts", shortcuts,
                "path", path,
                "customData", customData,
                "documentCategory", documentCategory,
                "contactPerson", contactPerson,
                "thumbnail", thumbnail,
                "indexStatus", indexStatus,
                "ancestors", ancestors);
    }
    
    public final static class Builder {
 
        private Optional<String> datasource = Optional.empty();
 
        private Optional<String> datasourceInstance = Optional.empty();
 
        private Optional<String> objectType = Optional.empty();
 
        private Optional<String> container = Optional.empty();
 
        private Optional<String> containerId = Optional.empty();
 
        private Optional<String> superContainerId = Optional.empty();
 
        private Optional<String> parentId = Optional.empty();
 
        private Optional<String> mimeType = Optional.empty();
 
        private Optional<String> documentId = Optional.empty();
 
        private Optional<String> loggingId = Optional.empty();
 
        private Optional<String> documentIdHash = Optional.empty();
 
        private Optional<OffsetDateTime> createTime = Optional.empty();
 
        private Optional<OffsetDateTime> updateTime = Optional.empty();
 
        private Optional<? extends Person> author = Optional.empty();
 
        private Optional<? extends Person> owner = Optional.empty();
 
        private Optional<? extends List<Person>> mentionedPeople = Optional.empty();
 
        private Optional<? extends DocumentVisibility> visibility = Optional.empty();
 
        private Optional<? extends List<String>> components = Optional.empty();
 
        private Optional<String> status = Optional.empty();
 
        private Optional<String> statusCategory = Optional.empty();
 
        private Optional<? extends List<PinDocument>> pins = Optional.empty();
 
        private Optional<String> priority = Optional.empty();
 
        private Optional<? extends Person> assignedTo = Optional.empty();
 
        private Optional<? extends Person> updatedBy = Optional.empty();
 
        private Optional<? extends List<String>> labels = Optional.empty();
 
        private Optional<? extends List<Collection>> collections = Optional.empty();
 
        private Optional<String> datasourceId = Optional.empty();
 
        private Optional<? extends DocumentInteractions> interactions = Optional.empty();
 
        private Optional<? extends Verification> verification = Optional.empty();
 
        private Optional<? extends ViewerInfo> viewerInfo = Optional.empty();
 
        private Optional<? extends ObjectPermissions> permissions = Optional.empty();
 
        private Optional<? extends CountInfo> visitCount = Optional.empty();
 
        private Optional<? extends List<Shortcut>> shortcuts = Optional.empty();
 
        private Optional<String> path = Optional.empty();
 
        private Optional<? extends Map<String, CustomDataValue>> customData = Optional.empty();
 
        private Optional<String> documentCategory = Optional.empty();
 
        private Optional<? extends Person> contactPerson = Optional.empty();
 
        private Optional<? extends Thumbnail> thumbnail = Optional.empty();
 
        private Optional<? extends IndexStatus> indexStatus = Optional.empty();
 
        private Optional<? extends List<Document>> ancestors = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder datasource(String datasource) {
            Utils.checkNotNull(datasource, "datasource");
            this.datasource = Optional.ofNullable(datasource);
            return this;
        }

        public Builder datasource(Optional<String> datasource) {
            Utils.checkNotNull(datasource, "datasource");
            this.datasource = datasource;
            return this;
        }

        /**
         * The datasource instance from which the document was extracted.
         */
        public Builder datasourceInstance(String datasourceInstance) {
            Utils.checkNotNull(datasourceInstance, "datasourceInstance");
            this.datasourceInstance = Optional.ofNullable(datasourceInstance);
            return this;
        }

        /**
         * The datasource instance from which the document was extracted.
         */
        public Builder datasourceInstance(Optional<String> datasourceInstance) {
            Utils.checkNotNull(datasourceInstance, "datasourceInstance");
            this.datasourceInstance = datasourceInstance;
            return this;
        }

        /**
         * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
         */
        public Builder objectType(String objectType) {
            Utils.checkNotNull(objectType, "objectType");
            this.objectType = Optional.ofNullable(objectType);
            return this;
        }

        /**
         * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
         */
        public Builder objectType(Optional<String> objectType) {
            Utils.checkNotNull(objectType, "objectType");
            this.objectType = objectType;
            return this;
        }

        /**
         * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
         */
        public Builder container(String container) {
            Utils.checkNotNull(container, "container");
            this.container = Optional.ofNullable(container);
            return this;
        }

        /**
         * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
         */
        public Builder container(Optional<String> container) {
            Utils.checkNotNull(container, "container");
            this.container = container;
            return this;
        }

        /**
         * The Glean Document ID of the container. Uniquely identifies the container.
         */
        public Builder containerId(String containerId) {
            Utils.checkNotNull(containerId, "containerId");
            this.containerId = Optional.ofNullable(containerId);
            return this;
        }

        /**
         * The Glean Document ID of the container. Uniquely identifies the container.
         */
        public Builder containerId(Optional<String> containerId) {
            Utils.checkNotNull(containerId, "containerId");
            this.containerId = containerId;
            return this;
        }

        /**
         * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
         */
        public Builder superContainerId(String superContainerId) {
            Utils.checkNotNull(superContainerId, "superContainerId");
            this.superContainerId = Optional.ofNullable(superContainerId);
            return this;
        }

        /**
         * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
         */
        public Builder superContainerId(Optional<String> superContainerId) {
            Utils.checkNotNull(superContainerId, "superContainerId");
            this.superContainerId = superContainerId;
            return this;
        }

        /**
         * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
         */
        public Builder parentId(Optional<String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }

        public Builder mimeType(String mimeType) {
            Utils.checkNotNull(mimeType, "mimeType");
            this.mimeType = Optional.ofNullable(mimeType);
            return this;
        }

        public Builder mimeType(Optional<String> mimeType) {
            Utils.checkNotNull(mimeType, "mimeType");
            this.mimeType = mimeType;
            return this;
        }

        /**
         * The index-wide unique identifier.
         */
        public Builder documentId(String documentId) {
            Utils.checkNotNull(documentId, "documentId");
            this.documentId = Optional.ofNullable(documentId);
            return this;
        }

        /**
         * The index-wide unique identifier.
         */
        public Builder documentId(Optional<String> documentId) {
            Utils.checkNotNull(documentId, "documentId");
            this.documentId = documentId;
            return this;
        }

        /**
         * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
         */
        public Builder loggingId(String loggingId) {
            Utils.checkNotNull(loggingId, "loggingId");
            this.loggingId = Optional.ofNullable(loggingId);
            return this;
        }

        /**
         * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
         */
        public Builder loggingId(Optional<String> loggingId) {
            Utils.checkNotNull(loggingId, "loggingId");
            this.loggingId = loggingId;
            return this;
        }

        /**
         * Hash of the Glean Document ID.
         */
        public Builder documentIdHash(String documentIdHash) {
            Utils.checkNotNull(documentIdHash, "documentIdHash");
            this.documentIdHash = Optional.ofNullable(documentIdHash);
            return this;
        }

        /**
         * Hash of the Glean Document ID.
         */
        public Builder documentIdHash(Optional<String> documentIdHash) {
            Utils.checkNotNull(documentIdHash, "documentIdHash");
            this.documentIdHash = documentIdHash;
            return this;
        }

        public Builder createTime(OffsetDateTime createTime) {
            Utils.checkNotNull(createTime, "createTime");
            this.createTime = Optional.ofNullable(createTime);
            return this;
        }

        public Builder createTime(Optional<OffsetDateTime> createTime) {
            Utils.checkNotNull(createTime, "createTime");
            this.createTime = createTime;
            return this;
        }

        public Builder updateTime(OffsetDateTime updateTime) {
            Utils.checkNotNull(updateTime, "updateTime");
            this.updateTime = Optional.ofNullable(updateTime);
            return this;
        }

        public Builder updateTime(Optional<OffsetDateTime> updateTime) {
            Utils.checkNotNull(updateTime, "updateTime");
            this.updateTime = updateTime;
            return this;
        }

        public Builder author(Person author) {
            Utils.checkNotNull(author, "author");
            this.author = Optional.ofNullable(author);
            return this;
        }

        public Builder author(Optional<? extends Person> author) {
            Utils.checkNotNull(author, "author");
            this.author = author;
            return this;
        }

        public Builder owner(Person owner) {
            Utils.checkNotNull(owner, "owner");
            this.owner = Optional.ofNullable(owner);
            return this;
        }

        public Builder owner(Optional<? extends Person> owner) {
            Utils.checkNotNull(owner, "owner");
            this.owner = owner;
            return this;
        }

        /**
         * A list of people mentioned in the document.
         */
        public Builder mentionedPeople(List<Person> mentionedPeople) {
            Utils.checkNotNull(mentionedPeople, "mentionedPeople");
            this.mentionedPeople = Optional.ofNullable(mentionedPeople);
            return this;
        }

        /**
         * A list of people mentioned in the document.
         */
        public Builder mentionedPeople(Optional<? extends List<Person>> mentionedPeople) {
            Utils.checkNotNull(mentionedPeople, "mentionedPeople");
            this.mentionedPeople = mentionedPeople;
            return this;
        }

        /**
         * The level of visibility of the document as understood by our system.
         */
        public Builder visibility(DocumentVisibility visibility) {
            Utils.checkNotNull(visibility, "visibility");
            this.visibility = Optional.ofNullable(visibility);
            return this;
        }

        /**
         * The level of visibility of the document as understood by our system.
         */
        public Builder visibility(Optional<? extends DocumentVisibility> visibility) {
            Utils.checkNotNull(visibility, "visibility");
            this.visibility = visibility;
            return this;
        }

        /**
         * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
         */
        public Builder components(List<String> components) {
            Utils.checkNotNull(components, "components");
            this.components = Optional.ofNullable(components);
            return this;
        }

        /**
         * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
         */
        public Builder components(Optional<? extends List<String>> components) {
            Utils.checkNotNull(components, "components");
            this.components = components;
            return this;
        }

        /**
         * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
         */
        public Builder statusCategory(String statusCategory) {
            Utils.checkNotNull(statusCategory, "statusCategory");
            this.statusCategory = Optional.ofNullable(statusCategory);
            return this;
        }

        /**
         * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
         */
        public Builder statusCategory(Optional<String> statusCategory) {
            Utils.checkNotNull(statusCategory, "statusCategory");
            this.statusCategory = statusCategory;
            return this;
        }

        /**
         * A list of stars associated with this result.  "Pin" is an older name.
         */
        public Builder pins(List<PinDocument> pins) {
            Utils.checkNotNull(pins, "pins");
            this.pins = Optional.ofNullable(pins);
            return this;
        }

        /**
         * A list of stars associated with this result.  "Pin" is an older name.
         */
        public Builder pins(Optional<? extends List<PinDocument>> pins) {
            Utils.checkNotNull(pins, "pins");
            this.pins = pins;
            return this;
        }

        /**
         * The document priority. Interpretation is datasource specific.
         */
        public Builder priority(String priority) {
            Utils.checkNotNull(priority, "priority");
            this.priority = Optional.ofNullable(priority);
            return this;
        }

        /**
         * The document priority. Interpretation is datasource specific.
         */
        public Builder priority(Optional<String> priority) {
            Utils.checkNotNull(priority, "priority");
            this.priority = priority;
            return this;
        }

        public Builder assignedTo(Person assignedTo) {
            Utils.checkNotNull(assignedTo, "assignedTo");
            this.assignedTo = Optional.ofNullable(assignedTo);
            return this;
        }

        public Builder assignedTo(Optional<? extends Person> assignedTo) {
            Utils.checkNotNull(assignedTo, "assignedTo");
            this.assignedTo = assignedTo;
            return this;
        }

        public Builder updatedBy(Person updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = Optional.ofNullable(updatedBy);
            return this;
        }

        public Builder updatedBy(Optional<? extends Person> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }

        /**
         * A list of tags for the document. Interpretation is datasource specific.
         */
        public Builder labels(List<String> labels) {
            Utils.checkNotNull(labels, "labels");
            this.labels = Optional.ofNullable(labels);
            return this;
        }

        /**
         * A list of tags for the document. Interpretation is datasource specific.
         */
        public Builder labels(Optional<? extends List<String>> labels) {
            Utils.checkNotNull(labels, "labels");
            this.labels = labels;
            return this;
        }

        /**
         * A list of collections that the document belongs to.
         */
        public Builder collections(List<Collection> collections) {
            Utils.checkNotNull(collections, "collections");
            this.collections = Optional.ofNullable(collections);
            return this;
        }

        /**
         * A list of collections that the document belongs to.
         */
        public Builder collections(Optional<? extends List<Collection>> collections) {
            Utils.checkNotNull(collections, "collections");
            this.collections = collections;
            return this;
        }

        /**
         * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
         */
        public Builder datasourceId(String datasourceId) {
            Utils.checkNotNull(datasourceId, "datasourceId");
            this.datasourceId = Optional.ofNullable(datasourceId);
            return this;
        }

        /**
         * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
         */
        public Builder datasourceId(Optional<String> datasourceId) {
            Utils.checkNotNull(datasourceId, "datasourceId");
            this.datasourceId = datasourceId;
            return this;
        }

        public Builder interactions(DocumentInteractions interactions) {
            Utils.checkNotNull(interactions, "interactions");
            this.interactions = Optional.ofNullable(interactions);
            return this;
        }

        public Builder interactions(Optional<? extends DocumentInteractions> interactions) {
            Utils.checkNotNull(interactions, "interactions");
            this.interactions = interactions;
            return this;
        }

        public Builder verification(Verification verification) {
            Utils.checkNotNull(verification, "verification");
            this.verification = Optional.ofNullable(verification);
            return this;
        }

        public Builder verification(Optional<? extends Verification> verification) {
            Utils.checkNotNull(verification, "verification");
            this.verification = verification;
            return this;
        }

        public Builder viewerInfo(ViewerInfo viewerInfo) {
            Utils.checkNotNull(viewerInfo, "viewerInfo");
            this.viewerInfo = Optional.ofNullable(viewerInfo);
            return this;
        }

        public Builder viewerInfo(Optional<? extends ViewerInfo> viewerInfo) {
            Utils.checkNotNull(viewerInfo, "viewerInfo");
            this.viewerInfo = viewerInfo;
            return this;
        }

        public Builder permissions(ObjectPermissions permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = Optional.ofNullable(permissions);
            return this;
        }

        public Builder permissions(Optional<? extends ObjectPermissions> permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = permissions;
            return this;
        }

        public Builder visitCount(CountInfo visitCount) {
            Utils.checkNotNull(visitCount, "visitCount");
            this.visitCount = Optional.ofNullable(visitCount);
            return this;
        }

        public Builder visitCount(Optional<? extends CountInfo> visitCount) {
            Utils.checkNotNull(visitCount, "visitCount");
            this.visitCount = visitCount;
            return this;
        }

        /**
         * A list of shortcuts of which destination URL is for the document.
         */
        public Builder shortcuts(List<Shortcut> shortcuts) {
            Utils.checkNotNull(shortcuts, "shortcuts");
            this.shortcuts = Optional.ofNullable(shortcuts);
            return this;
        }

        /**
         * A list of shortcuts of which destination URL is for the document.
         */
        public Builder shortcuts(Optional<? extends List<Shortcut>> shortcuts) {
            Utils.checkNotNull(shortcuts, "shortcuts");
            this.shortcuts = shortcuts;
            return this;
        }

        /**
         * For file datasources like onedrive/github etc this has the path to the file
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = Optional.ofNullable(path);
            return this;
        }

        /**
         * For file datasources like onedrive/github etc this has the path to the file
         */
        public Builder path(Optional<String> path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }

        /**
         * Custom fields specific to individual datasources
         */
        public Builder customData(Map<String, CustomDataValue> customData) {
            Utils.checkNotNull(customData, "customData");
            this.customData = Optional.ofNullable(customData);
            return this;
        }

        /**
         * Custom fields specific to individual datasources
         */
        public Builder customData(Optional<? extends Map<String, CustomDataValue>> customData) {
            Utils.checkNotNull(customData, "customData");
            this.customData = customData;
            return this;
        }

        /**
         * The document's document_category(.proto).
         */
        public Builder documentCategory(String documentCategory) {
            Utils.checkNotNull(documentCategory, "documentCategory");
            this.documentCategory = Optional.ofNullable(documentCategory);
            return this;
        }

        /**
         * The document's document_category(.proto).
         */
        public Builder documentCategory(Optional<String> documentCategory) {
            Utils.checkNotNull(documentCategory, "documentCategory");
            this.documentCategory = documentCategory;
            return this;
        }

        public Builder contactPerson(Person contactPerson) {
            Utils.checkNotNull(contactPerson, "contactPerson");
            this.contactPerson = Optional.ofNullable(contactPerson);
            return this;
        }

        public Builder contactPerson(Optional<? extends Person> contactPerson) {
            Utils.checkNotNull(contactPerson, "contactPerson");
            this.contactPerson = contactPerson;
            return this;
        }

        public Builder thumbnail(Thumbnail thumbnail) {
            Utils.checkNotNull(thumbnail, "thumbnail");
            this.thumbnail = Optional.ofNullable(thumbnail);
            return this;
        }

        public Builder thumbnail(Optional<? extends Thumbnail> thumbnail) {
            Utils.checkNotNull(thumbnail, "thumbnail");
            this.thumbnail = thumbnail;
            return this;
        }

        public Builder indexStatus(IndexStatus indexStatus) {
            Utils.checkNotNull(indexStatus, "indexStatus");
            this.indexStatus = Optional.ofNullable(indexStatus);
            return this;
        }

        public Builder indexStatus(Optional<? extends IndexStatus> indexStatus) {
            Utils.checkNotNull(indexStatus, "indexStatus");
            this.indexStatus = indexStatus;
            return this;
        }

        /**
         * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
         */
        public Builder ancestors(List<Document> ancestors) {
            Utils.checkNotNull(ancestors, "ancestors");
            this.ancestors = Optional.ofNullable(ancestors);
            return this;
        }

        /**
         * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
         */
        public Builder ancestors(Optional<? extends List<Document>> ancestors) {
            Utils.checkNotNull(ancestors, "ancestors");
            this.ancestors = ancestors;
            return this;
        }
        
        public DocumentMetadata build() {
            return new DocumentMetadata(
                datasource,
                datasourceInstance,
                objectType,
                container,
                containerId,
                superContainerId,
                parentId,
                mimeType,
                documentId,
                loggingId,
                documentIdHash,
                createTime,
                updateTime,
                author,
                owner,
                mentionedPeople,
                visibility,
                components,
                status,
                statusCategory,
                pins,
                priority,
                assignedTo,
                updatedBy,
                labels,
                collections,
                datasourceId,
                interactions,
                verification,
                viewerInfo,
                permissions,
                visitCount,
                shortcuts,
                path,
                customData,
                documentCategory,
                contactPerson,
                thumbnail,
                indexStatus,
                ancestors);
        }
    }
}
