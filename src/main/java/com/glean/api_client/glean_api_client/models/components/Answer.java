/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.glean_api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.glean_api_client.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class Answer {

    /**
     * The opaque ID of the Answer.
     */
    @JsonProperty("id")
    private long id;

    /**
     * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("docId")
    private Optional<String> docId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("question")
    private Optional<String> question;

    /**
     * Additional ways of phrasing this question.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("questionVariations")
    private Optional<? extends List<String>> questionVariations;

    /**
     * The plain text answer to the question.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bodyText")
    private Optional<String> bodyText;

    /**
     * The parent board ID of this Answer, or 0 if it's a floating Answer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("boardId")
    private Optional<Long> boardId;

    /**
     * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audienceFilters")
    private Optional<? extends List<FacetFilter>> audienceFilters;

    /**
     * A list of user roles for the answer added by the owner.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("addedRoles")
    private Optional<? extends List<UserRoleSpecification>> addedRoles;

    /**
     * A list of user roles for the answer removed by the owner.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("removedRoles")
    private Optional<? extends List<UserRoleSpecification>> removedRoles;

    /**
     * A list of roles for this answer explicitly granted by an owner, editor, or admin.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("roles")
    private Optional<? extends List<UserRoleSpecification>> roles;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceDocumentSpec")
    private Optional<? extends DocumentSpecUnion> sourceDocumentSpec;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceType")
    private Optional<? extends AnswerSourceType> sourceType;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("permissions")
    private Optional<? extends ObjectPermissions> permissions;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("combinedAnswerText")
    private Optional<? extends StructuredText> combinedAnswerText;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("likes")
    private Optional<? extends AnswerLikes> likes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("author")
    private Optional<? extends Person> author;

    /**
     * The time the answer was created in ISO format (ISO 8601).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createTime")
    private Optional<OffsetDateTime> createTime;

    /**
     * The time the answer was last updated in ISO format (ISO 8601).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updateTime")
    private Optional<OffsetDateTime> updateTime;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedBy")
    private Optional<? extends Person> updatedBy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("verification")
    private Optional<? extends Verification> verification;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("board")
    private Optional<? extends AnswerBoard> board;

    /**
     * The collections to which the answer belongs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("collections")
    private Optional<? extends List<Collection>> collections;

    /**
     * The document's document_category(.proto).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("documentCategory")
    private Optional<String> documentCategory;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceDocument")
    private Optional<? extends Document> sourceDocument;

    @JsonCreator
    public Answer(
            @JsonProperty("id") long id,
            @JsonProperty("docId") Optional<String> docId,
            @JsonProperty("question") Optional<String> question,
            @JsonProperty("questionVariations") Optional<? extends List<String>> questionVariations,
            @JsonProperty("bodyText") Optional<String> bodyText,
            @JsonProperty("boardId") Optional<Long> boardId,
            @JsonProperty("audienceFilters") Optional<? extends List<FacetFilter>> audienceFilters,
            @JsonProperty("addedRoles") Optional<? extends List<UserRoleSpecification>> addedRoles,
            @JsonProperty("removedRoles") Optional<? extends List<UserRoleSpecification>> removedRoles,
            @JsonProperty("roles") Optional<? extends List<UserRoleSpecification>> roles,
            @JsonProperty("sourceDocumentSpec") Optional<? extends DocumentSpecUnion> sourceDocumentSpec,
            @JsonProperty("sourceType") Optional<? extends AnswerSourceType> sourceType,
            @JsonProperty("permissions") Optional<? extends ObjectPermissions> permissions,
            @JsonProperty("combinedAnswerText") Optional<? extends StructuredText> combinedAnswerText,
            @JsonProperty("likes") Optional<? extends AnswerLikes> likes,
            @JsonProperty("author") Optional<? extends Person> author,
            @JsonProperty("createTime") Optional<OffsetDateTime> createTime,
            @JsonProperty("updateTime") Optional<OffsetDateTime> updateTime,
            @JsonProperty("updatedBy") Optional<? extends Person> updatedBy,
            @JsonProperty("verification") Optional<? extends Verification> verification,
            @JsonProperty("board") Optional<? extends AnswerBoard> board,
            @JsonProperty("collections") Optional<? extends List<Collection>> collections,
            @JsonProperty("documentCategory") Optional<String> documentCategory,
            @JsonProperty("sourceDocument") Optional<? extends Document> sourceDocument) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(docId, "docId");
        Utils.checkNotNull(question, "question");
        Utils.checkNotNull(questionVariations, "questionVariations");
        Utils.checkNotNull(bodyText, "bodyText");
        Utils.checkNotNull(boardId, "boardId");
        Utils.checkNotNull(audienceFilters, "audienceFilters");
        Utils.checkNotNull(addedRoles, "addedRoles");
        Utils.checkNotNull(removedRoles, "removedRoles");
        Utils.checkNotNull(roles, "roles");
        Utils.checkNotNull(sourceDocumentSpec, "sourceDocumentSpec");
        Utils.checkNotNull(sourceType, "sourceType");
        Utils.checkNotNull(permissions, "permissions");
        Utils.checkNotNull(combinedAnswerText, "combinedAnswerText");
        Utils.checkNotNull(likes, "likes");
        Utils.checkNotNull(author, "author");
        Utils.checkNotNull(createTime, "createTime");
        Utils.checkNotNull(updateTime, "updateTime");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(verification, "verification");
        Utils.checkNotNull(board, "board");
        Utils.checkNotNull(collections, "collections");
        Utils.checkNotNull(documentCategory, "documentCategory");
        Utils.checkNotNull(sourceDocument, "sourceDocument");
        this.id = id;
        this.docId = docId;
        this.question = question;
        this.questionVariations = questionVariations;
        this.bodyText = bodyText;
        this.boardId = boardId;
        this.audienceFilters = audienceFilters;
        this.addedRoles = addedRoles;
        this.removedRoles = removedRoles;
        this.roles = roles;
        this.sourceDocumentSpec = sourceDocumentSpec;
        this.sourceType = sourceType;
        this.permissions = permissions;
        this.combinedAnswerText = combinedAnswerText;
        this.likes = likes;
        this.author = author;
        this.createTime = createTime;
        this.updateTime = updateTime;
        this.updatedBy = updatedBy;
        this.verification = verification;
        this.board = board;
        this.collections = collections;
        this.documentCategory = documentCategory;
        this.sourceDocument = sourceDocument;
    }
    
    public Answer(
            long id) {
        this(id, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The opaque ID of the Answer.
     */
    @JsonIgnore
    public long id() {
        return id;
    }

    /**
     * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
     */
    @JsonIgnore
    public Optional<String> docId() {
        return docId;
    }

    @JsonIgnore
    public Optional<String> question() {
        return question;
    }

    /**
     * Additional ways of phrasing this question.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> questionVariations() {
        return (Optional<List<String>>) questionVariations;
    }

    /**
     * The plain text answer to the question.
     */
    @JsonIgnore
    public Optional<String> bodyText() {
        return bodyText;
    }

    /**
     * The parent board ID of this Answer, or 0 if it's a floating Answer.
     */
    @JsonIgnore
    public Optional<Long> boardId() {
        return boardId;
    }

    /**
     * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FacetFilter>> audienceFilters() {
        return (Optional<List<FacetFilter>>) audienceFilters;
    }

    /**
     * A list of user roles for the answer added by the owner.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<UserRoleSpecification>> addedRoles() {
        return (Optional<List<UserRoleSpecification>>) addedRoles;
    }

    /**
     * A list of user roles for the answer removed by the owner.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<UserRoleSpecification>> removedRoles() {
        return (Optional<List<UserRoleSpecification>>) removedRoles;
    }

    /**
     * A list of roles for this answer explicitly granted by an owner, editor, or admin.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<UserRoleSpecification>> roles() {
        return (Optional<List<UserRoleSpecification>>) roles;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DocumentSpecUnion> sourceDocumentSpec() {
        return (Optional<DocumentSpecUnion>) sourceDocumentSpec;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AnswerSourceType> sourceType() {
        return (Optional<AnswerSourceType>) sourceType;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ObjectPermissions> permissions() {
        return (Optional<ObjectPermissions>) permissions;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StructuredText> combinedAnswerText() {
        return (Optional<StructuredText>) combinedAnswerText;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AnswerLikes> likes() {
        return (Optional<AnswerLikes>) likes;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> author() {
        return (Optional<Person>) author;
    }

    /**
     * The time the answer was created in ISO format (ISO 8601).
     */
    @JsonIgnore
    public Optional<OffsetDateTime> createTime() {
        return createTime;
    }

    /**
     * The time the answer was last updated in ISO format (ISO 8601).
     */
    @JsonIgnore
    public Optional<OffsetDateTime> updateTime() {
        return updateTime;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Person> updatedBy() {
        return (Optional<Person>) updatedBy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Verification> verification() {
        return (Optional<Verification>) verification;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AnswerBoard> board() {
        return (Optional<AnswerBoard>) board;
    }

    /**
     * The collections to which the answer belongs.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Collection>> collections() {
        return (Optional<List<Collection>>) collections;
    }

    /**
     * The document's document_category(.proto).
     */
    @JsonIgnore
    public Optional<String> documentCategory() {
        return documentCategory;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Document> sourceDocument() {
        return (Optional<Document>) sourceDocument;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The opaque ID of the Answer.
     */
    public Answer withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
     */
    public Answer withDocId(String docId) {
        Utils.checkNotNull(docId, "docId");
        this.docId = Optional.ofNullable(docId);
        return this;
    }

    /**
     * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
     */
    public Answer withDocId(Optional<String> docId) {
        Utils.checkNotNull(docId, "docId");
        this.docId = docId;
        return this;
    }

    public Answer withQuestion(String question) {
        Utils.checkNotNull(question, "question");
        this.question = Optional.ofNullable(question);
        return this;
    }

    public Answer withQuestion(Optional<String> question) {
        Utils.checkNotNull(question, "question");
        this.question = question;
        return this;
    }

    /**
     * Additional ways of phrasing this question.
     */
    public Answer withQuestionVariations(List<String> questionVariations) {
        Utils.checkNotNull(questionVariations, "questionVariations");
        this.questionVariations = Optional.ofNullable(questionVariations);
        return this;
    }

    /**
     * Additional ways of phrasing this question.
     */
    public Answer withQuestionVariations(Optional<? extends List<String>> questionVariations) {
        Utils.checkNotNull(questionVariations, "questionVariations");
        this.questionVariations = questionVariations;
        return this;
    }

    /**
     * The plain text answer to the question.
     */
    public Answer withBodyText(String bodyText) {
        Utils.checkNotNull(bodyText, "bodyText");
        this.bodyText = Optional.ofNullable(bodyText);
        return this;
    }

    /**
     * The plain text answer to the question.
     */
    public Answer withBodyText(Optional<String> bodyText) {
        Utils.checkNotNull(bodyText, "bodyText");
        this.bodyText = bodyText;
        return this;
    }

    /**
     * The parent board ID of this Answer, or 0 if it's a floating Answer.
     */
    public Answer withBoardId(long boardId) {
        Utils.checkNotNull(boardId, "boardId");
        this.boardId = Optional.ofNullable(boardId);
        return this;
    }

    /**
     * The parent board ID of this Answer, or 0 if it's a floating Answer.
     */
    public Answer withBoardId(Optional<Long> boardId) {
        Utils.checkNotNull(boardId, "boardId");
        this.boardId = boardId;
        return this;
    }

    /**
     * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
     */
    public Answer withAudienceFilters(List<FacetFilter> audienceFilters) {
        Utils.checkNotNull(audienceFilters, "audienceFilters");
        this.audienceFilters = Optional.ofNullable(audienceFilters);
        return this;
    }

    /**
     * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
     */
    public Answer withAudienceFilters(Optional<? extends List<FacetFilter>> audienceFilters) {
        Utils.checkNotNull(audienceFilters, "audienceFilters");
        this.audienceFilters = audienceFilters;
        return this;
    }

    /**
     * A list of user roles for the answer added by the owner.
     */
    public Answer withAddedRoles(List<UserRoleSpecification> addedRoles) {
        Utils.checkNotNull(addedRoles, "addedRoles");
        this.addedRoles = Optional.ofNullable(addedRoles);
        return this;
    }

    /**
     * A list of user roles for the answer added by the owner.
     */
    public Answer withAddedRoles(Optional<? extends List<UserRoleSpecification>> addedRoles) {
        Utils.checkNotNull(addedRoles, "addedRoles");
        this.addedRoles = addedRoles;
        return this;
    }

    /**
     * A list of user roles for the answer removed by the owner.
     */
    public Answer withRemovedRoles(List<UserRoleSpecification> removedRoles) {
        Utils.checkNotNull(removedRoles, "removedRoles");
        this.removedRoles = Optional.ofNullable(removedRoles);
        return this;
    }

    /**
     * A list of user roles for the answer removed by the owner.
     */
    public Answer withRemovedRoles(Optional<? extends List<UserRoleSpecification>> removedRoles) {
        Utils.checkNotNull(removedRoles, "removedRoles");
        this.removedRoles = removedRoles;
        return this;
    }

    /**
     * A list of roles for this answer explicitly granted by an owner, editor, or admin.
     */
    public Answer withRoles(List<UserRoleSpecification> roles) {
        Utils.checkNotNull(roles, "roles");
        this.roles = Optional.ofNullable(roles);
        return this;
    }

    /**
     * A list of roles for this answer explicitly granted by an owner, editor, or admin.
     */
    public Answer withRoles(Optional<? extends List<UserRoleSpecification>> roles) {
        Utils.checkNotNull(roles, "roles");
        this.roles = roles;
        return this;
    }

    public Answer withSourceDocumentSpec(DocumentSpecUnion sourceDocumentSpec) {
        Utils.checkNotNull(sourceDocumentSpec, "sourceDocumentSpec");
        this.sourceDocumentSpec = Optional.ofNullable(sourceDocumentSpec);
        return this;
    }

    public Answer withSourceDocumentSpec(Optional<? extends DocumentSpecUnion> sourceDocumentSpec) {
        Utils.checkNotNull(sourceDocumentSpec, "sourceDocumentSpec");
        this.sourceDocumentSpec = sourceDocumentSpec;
        return this;
    }

    public Answer withSourceType(AnswerSourceType sourceType) {
        Utils.checkNotNull(sourceType, "sourceType");
        this.sourceType = Optional.ofNullable(sourceType);
        return this;
    }

    public Answer withSourceType(Optional<? extends AnswerSourceType> sourceType) {
        Utils.checkNotNull(sourceType, "sourceType");
        this.sourceType = sourceType;
        return this;
    }

    public Answer withPermissions(ObjectPermissions permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = Optional.ofNullable(permissions);
        return this;
    }

    public Answer withPermissions(Optional<? extends ObjectPermissions> permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = permissions;
        return this;
    }

    public Answer withCombinedAnswerText(StructuredText combinedAnswerText) {
        Utils.checkNotNull(combinedAnswerText, "combinedAnswerText");
        this.combinedAnswerText = Optional.ofNullable(combinedAnswerText);
        return this;
    }

    public Answer withCombinedAnswerText(Optional<? extends StructuredText> combinedAnswerText) {
        Utils.checkNotNull(combinedAnswerText, "combinedAnswerText");
        this.combinedAnswerText = combinedAnswerText;
        return this;
    }

    public Answer withLikes(AnswerLikes likes) {
        Utils.checkNotNull(likes, "likes");
        this.likes = Optional.ofNullable(likes);
        return this;
    }

    public Answer withLikes(Optional<? extends AnswerLikes> likes) {
        Utils.checkNotNull(likes, "likes");
        this.likes = likes;
        return this;
    }

    public Answer withAuthor(Person author) {
        Utils.checkNotNull(author, "author");
        this.author = Optional.ofNullable(author);
        return this;
    }

    public Answer withAuthor(Optional<? extends Person> author) {
        Utils.checkNotNull(author, "author");
        this.author = author;
        return this;
    }

    /**
     * The time the answer was created in ISO format (ISO 8601).
     */
    public Answer withCreateTime(OffsetDateTime createTime) {
        Utils.checkNotNull(createTime, "createTime");
        this.createTime = Optional.ofNullable(createTime);
        return this;
    }

    /**
     * The time the answer was created in ISO format (ISO 8601).
     */
    public Answer withCreateTime(Optional<OffsetDateTime> createTime) {
        Utils.checkNotNull(createTime, "createTime");
        this.createTime = createTime;
        return this;
    }

    /**
     * The time the answer was last updated in ISO format (ISO 8601).
     */
    public Answer withUpdateTime(OffsetDateTime updateTime) {
        Utils.checkNotNull(updateTime, "updateTime");
        this.updateTime = Optional.ofNullable(updateTime);
        return this;
    }

    /**
     * The time the answer was last updated in ISO format (ISO 8601).
     */
    public Answer withUpdateTime(Optional<OffsetDateTime> updateTime) {
        Utils.checkNotNull(updateTime, "updateTime");
        this.updateTime = updateTime;
        return this;
    }

    public Answer withUpdatedBy(Person updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = Optional.ofNullable(updatedBy);
        return this;
    }

    public Answer withUpdatedBy(Optional<? extends Person> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    public Answer withVerification(Verification verification) {
        Utils.checkNotNull(verification, "verification");
        this.verification = Optional.ofNullable(verification);
        return this;
    }

    public Answer withVerification(Optional<? extends Verification> verification) {
        Utils.checkNotNull(verification, "verification");
        this.verification = verification;
        return this;
    }

    public Answer withBoard(AnswerBoard board) {
        Utils.checkNotNull(board, "board");
        this.board = Optional.ofNullable(board);
        return this;
    }

    public Answer withBoard(Optional<? extends AnswerBoard> board) {
        Utils.checkNotNull(board, "board");
        this.board = board;
        return this;
    }

    /**
     * The collections to which the answer belongs.
     */
    public Answer withCollections(List<Collection> collections) {
        Utils.checkNotNull(collections, "collections");
        this.collections = Optional.ofNullable(collections);
        return this;
    }

    /**
     * The collections to which the answer belongs.
     */
    public Answer withCollections(Optional<? extends List<Collection>> collections) {
        Utils.checkNotNull(collections, "collections");
        this.collections = collections;
        return this;
    }

    /**
     * The document's document_category(.proto).
     */
    public Answer withDocumentCategory(String documentCategory) {
        Utils.checkNotNull(documentCategory, "documentCategory");
        this.documentCategory = Optional.ofNullable(documentCategory);
        return this;
    }

    /**
     * The document's document_category(.proto).
     */
    public Answer withDocumentCategory(Optional<String> documentCategory) {
        Utils.checkNotNull(documentCategory, "documentCategory");
        this.documentCategory = documentCategory;
        return this;
    }

    public Answer withSourceDocument(Document sourceDocument) {
        Utils.checkNotNull(sourceDocument, "sourceDocument");
        this.sourceDocument = Optional.ofNullable(sourceDocument);
        return this;
    }

    public Answer withSourceDocument(Optional<? extends Document> sourceDocument) {
        Utils.checkNotNull(sourceDocument, "sourceDocument");
        this.sourceDocument = sourceDocument;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Answer other = (Answer) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.docId, other.docId) &&
            Objects.deepEquals(this.question, other.question) &&
            Objects.deepEquals(this.questionVariations, other.questionVariations) &&
            Objects.deepEquals(this.bodyText, other.bodyText) &&
            Objects.deepEquals(this.boardId, other.boardId) &&
            Objects.deepEquals(this.audienceFilters, other.audienceFilters) &&
            Objects.deepEquals(this.addedRoles, other.addedRoles) &&
            Objects.deepEquals(this.removedRoles, other.removedRoles) &&
            Objects.deepEquals(this.roles, other.roles) &&
            Objects.deepEquals(this.sourceDocumentSpec, other.sourceDocumentSpec) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.permissions, other.permissions) &&
            Objects.deepEquals(this.combinedAnswerText, other.combinedAnswerText) &&
            Objects.deepEquals(this.likes, other.likes) &&
            Objects.deepEquals(this.author, other.author) &&
            Objects.deepEquals(this.createTime, other.createTime) &&
            Objects.deepEquals(this.updateTime, other.updateTime) &&
            Objects.deepEquals(this.updatedBy, other.updatedBy) &&
            Objects.deepEquals(this.verification, other.verification) &&
            Objects.deepEquals(this.board, other.board) &&
            Objects.deepEquals(this.collections, other.collections) &&
            Objects.deepEquals(this.documentCategory, other.documentCategory) &&
            Objects.deepEquals(this.sourceDocument, other.sourceDocument);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            docId,
            question,
            questionVariations,
            bodyText,
            boardId,
            audienceFilters,
            addedRoles,
            removedRoles,
            roles,
            sourceDocumentSpec,
            sourceType,
            permissions,
            combinedAnswerText,
            likes,
            author,
            createTime,
            updateTime,
            updatedBy,
            verification,
            board,
            collections,
            documentCategory,
            sourceDocument);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Answer.class,
                "id", id,
                "docId", docId,
                "question", question,
                "questionVariations", questionVariations,
                "bodyText", bodyText,
                "boardId", boardId,
                "audienceFilters", audienceFilters,
                "addedRoles", addedRoles,
                "removedRoles", removedRoles,
                "roles", roles,
                "sourceDocumentSpec", sourceDocumentSpec,
                "sourceType", sourceType,
                "permissions", permissions,
                "combinedAnswerText", combinedAnswerText,
                "likes", likes,
                "author", author,
                "createTime", createTime,
                "updateTime", updateTime,
                "updatedBy", updatedBy,
                "verification", verification,
                "board", board,
                "collections", collections,
                "documentCategory", documentCategory,
                "sourceDocument", sourceDocument);
    }
    
    public final static class Builder {
 
        private Long id;
 
        private Optional<String> docId = Optional.empty();
 
        private Optional<String> question = Optional.empty();
 
        private Optional<? extends List<String>> questionVariations = Optional.empty();
 
        private Optional<String> bodyText = Optional.empty();
 
        private Optional<Long> boardId = Optional.empty();
 
        private Optional<? extends List<FacetFilter>> audienceFilters = Optional.empty();
 
        private Optional<? extends List<UserRoleSpecification>> addedRoles = Optional.empty();
 
        private Optional<? extends List<UserRoleSpecification>> removedRoles = Optional.empty();
 
        private Optional<? extends List<UserRoleSpecification>> roles = Optional.empty();
 
        private Optional<? extends DocumentSpecUnion> sourceDocumentSpec = Optional.empty();
 
        private Optional<? extends AnswerSourceType> sourceType = Optional.empty();
 
        private Optional<? extends ObjectPermissions> permissions = Optional.empty();
 
        private Optional<? extends StructuredText> combinedAnswerText = Optional.empty();
 
        private Optional<? extends AnswerLikes> likes = Optional.empty();
 
        private Optional<? extends Person> author = Optional.empty();
 
        private Optional<OffsetDateTime> createTime = Optional.empty();
 
        private Optional<OffsetDateTime> updateTime = Optional.empty();
 
        private Optional<? extends Person> updatedBy = Optional.empty();
 
        private Optional<? extends Verification> verification = Optional.empty();
 
        private Optional<? extends AnswerBoard> board = Optional.empty();
 
        private Optional<? extends List<Collection>> collections = Optional.empty();
 
        private Optional<String> documentCategory = Optional.empty();
 
        private Optional<? extends Document> sourceDocument = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The opaque ID of the Answer.
         */
        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
         */
        public Builder docId(String docId) {
            Utils.checkNotNull(docId, "docId");
            this.docId = Optional.ofNullable(docId);
            return this;
        }

        /**
         * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
         */
        public Builder docId(Optional<String> docId) {
            Utils.checkNotNull(docId, "docId");
            this.docId = docId;
            return this;
        }

        public Builder question(String question) {
            Utils.checkNotNull(question, "question");
            this.question = Optional.ofNullable(question);
            return this;
        }

        public Builder question(Optional<String> question) {
            Utils.checkNotNull(question, "question");
            this.question = question;
            return this;
        }

        /**
         * Additional ways of phrasing this question.
         */
        public Builder questionVariations(List<String> questionVariations) {
            Utils.checkNotNull(questionVariations, "questionVariations");
            this.questionVariations = Optional.ofNullable(questionVariations);
            return this;
        }

        /**
         * Additional ways of phrasing this question.
         */
        public Builder questionVariations(Optional<? extends List<String>> questionVariations) {
            Utils.checkNotNull(questionVariations, "questionVariations");
            this.questionVariations = questionVariations;
            return this;
        }

        /**
         * The plain text answer to the question.
         */
        public Builder bodyText(String bodyText) {
            Utils.checkNotNull(bodyText, "bodyText");
            this.bodyText = Optional.ofNullable(bodyText);
            return this;
        }

        /**
         * The plain text answer to the question.
         */
        public Builder bodyText(Optional<String> bodyText) {
            Utils.checkNotNull(bodyText, "bodyText");
            this.bodyText = bodyText;
            return this;
        }

        /**
         * The parent board ID of this Answer, or 0 if it's a floating Answer.
         */
        public Builder boardId(long boardId) {
            Utils.checkNotNull(boardId, "boardId");
            this.boardId = Optional.ofNullable(boardId);
            return this;
        }

        /**
         * The parent board ID of this Answer, or 0 if it's a floating Answer.
         */
        public Builder boardId(Optional<Long> boardId) {
            Utils.checkNotNull(boardId, "boardId");
            this.boardId = boardId;
            return this;
        }

        /**
         * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
         */
        public Builder audienceFilters(List<FacetFilter> audienceFilters) {
            Utils.checkNotNull(audienceFilters, "audienceFilters");
            this.audienceFilters = Optional.ofNullable(audienceFilters);
            return this;
        }

        /**
         * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
         */
        public Builder audienceFilters(Optional<? extends List<FacetFilter>> audienceFilters) {
            Utils.checkNotNull(audienceFilters, "audienceFilters");
            this.audienceFilters = audienceFilters;
            return this;
        }

        /**
         * A list of user roles for the answer added by the owner.
         */
        public Builder addedRoles(List<UserRoleSpecification> addedRoles) {
            Utils.checkNotNull(addedRoles, "addedRoles");
            this.addedRoles = Optional.ofNullable(addedRoles);
            return this;
        }

        /**
         * A list of user roles for the answer added by the owner.
         */
        public Builder addedRoles(Optional<? extends List<UserRoleSpecification>> addedRoles) {
            Utils.checkNotNull(addedRoles, "addedRoles");
            this.addedRoles = addedRoles;
            return this;
        }

        /**
         * A list of user roles for the answer removed by the owner.
         */
        public Builder removedRoles(List<UserRoleSpecification> removedRoles) {
            Utils.checkNotNull(removedRoles, "removedRoles");
            this.removedRoles = Optional.ofNullable(removedRoles);
            return this;
        }

        /**
         * A list of user roles for the answer removed by the owner.
         */
        public Builder removedRoles(Optional<? extends List<UserRoleSpecification>> removedRoles) {
            Utils.checkNotNull(removedRoles, "removedRoles");
            this.removedRoles = removedRoles;
            return this;
        }

        /**
         * A list of roles for this answer explicitly granted by an owner, editor, or admin.
         */
        public Builder roles(List<UserRoleSpecification> roles) {
            Utils.checkNotNull(roles, "roles");
            this.roles = Optional.ofNullable(roles);
            return this;
        }

        /**
         * A list of roles for this answer explicitly granted by an owner, editor, or admin.
         */
        public Builder roles(Optional<? extends List<UserRoleSpecification>> roles) {
            Utils.checkNotNull(roles, "roles");
            this.roles = roles;
            return this;
        }

        public Builder sourceDocumentSpec(DocumentSpecUnion sourceDocumentSpec) {
            Utils.checkNotNull(sourceDocumentSpec, "sourceDocumentSpec");
            this.sourceDocumentSpec = Optional.ofNullable(sourceDocumentSpec);
            return this;
        }

        public Builder sourceDocumentSpec(Optional<? extends DocumentSpecUnion> sourceDocumentSpec) {
            Utils.checkNotNull(sourceDocumentSpec, "sourceDocumentSpec");
            this.sourceDocumentSpec = sourceDocumentSpec;
            return this;
        }

        public Builder sourceType(AnswerSourceType sourceType) {
            Utils.checkNotNull(sourceType, "sourceType");
            this.sourceType = Optional.ofNullable(sourceType);
            return this;
        }

        public Builder sourceType(Optional<? extends AnswerSourceType> sourceType) {
            Utils.checkNotNull(sourceType, "sourceType");
            this.sourceType = sourceType;
            return this;
        }

        public Builder permissions(ObjectPermissions permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = Optional.ofNullable(permissions);
            return this;
        }

        public Builder permissions(Optional<? extends ObjectPermissions> permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = permissions;
            return this;
        }

        public Builder combinedAnswerText(StructuredText combinedAnswerText) {
            Utils.checkNotNull(combinedAnswerText, "combinedAnswerText");
            this.combinedAnswerText = Optional.ofNullable(combinedAnswerText);
            return this;
        }

        public Builder combinedAnswerText(Optional<? extends StructuredText> combinedAnswerText) {
            Utils.checkNotNull(combinedAnswerText, "combinedAnswerText");
            this.combinedAnswerText = combinedAnswerText;
            return this;
        }

        public Builder likes(AnswerLikes likes) {
            Utils.checkNotNull(likes, "likes");
            this.likes = Optional.ofNullable(likes);
            return this;
        }

        public Builder likes(Optional<? extends AnswerLikes> likes) {
            Utils.checkNotNull(likes, "likes");
            this.likes = likes;
            return this;
        }

        public Builder author(Person author) {
            Utils.checkNotNull(author, "author");
            this.author = Optional.ofNullable(author);
            return this;
        }

        public Builder author(Optional<? extends Person> author) {
            Utils.checkNotNull(author, "author");
            this.author = author;
            return this;
        }

        /**
         * The time the answer was created in ISO format (ISO 8601).
         */
        public Builder createTime(OffsetDateTime createTime) {
            Utils.checkNotNull(createTime, "createTime");
            this.createTime = Optional.ofNullable(createTime);
            return this;
        }

        /**
         * The time the answer was created in ISO format (ISO 8601).
         */
        public Builder createTime(Optional<OffsetDateTime> createTime) {
            Utils.checkNotNull(createTime, "createTime");
            this.createTime = createTime;
            return this;
        }

        /**
         * The time the answer was last updated in ISO format (ISO 8601).
         */
        public Builder updateTime(OffsetDateTime updateTime) {
            Utils.checkNotNull(updateTime, "updateTime");
            this.updateTime = Optional.ofNullable(updateTime);
            return this;
        }

        /**
         * The time the answer was last updated in ISO format (ISO 8601).
         */
        public Builder updateTime(Optional<OffsetDateTime> updateTime) {
            Utils.checkNotNull(updateTime, "updateTime");
            this.updateTime = updateTime;
            return this;
        }

        public Builder updatedBy(Person updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = Optional.ofNullable(updatedBy);
            return this;
        }

        public Builder updatedBy(Optional<? extends Person> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }

        public Builder verification(Verification verification) {
            Utils.checkNotNull(verification, "verification");
            this.verification = Optional.ofNullable(verification);
            return this;
        }

        public Builder verification(Optional<? extends Verification> verification) {
            Utils.checkNotNull(verification, "verification");
            this.verification = verification;
            return this;
        }

        public Builder board(AnswerBoard board) {
            Utils.checkNotNull(board, "board");
            this.board = Optional.ofNullable(board);
            return this;
        }

        public Builder board(Optional<? extends AnswerBoard> board) {
            Utils.checkNotNull(board, "board");
            this.board = board;
            return this;
        }

        /**
         * The collections to which the answer belongs.
         */
        public Builder collections(List<Collection> collections) {
            Utils.checkNotNull(collections, "collections");
            this.collections = Optional.ofNullable(collections);
            return this;
        }

        /**
         * The collections to which the answer belongs.
         */
        public Builder collections(Optional<? extends List<Collection>> collections) {
            Utils.checkNotNull(collections, "collections");
            this.collections = collections;
            return this;
        }

        /**
         * The document's document_category(.proto).
         */
        public Builder documentCategory(String documentCategory) {
            Utils.checkNotNull(documentCategory, "documentCategory");
            this.documentCategory = Optional.ofNullable(documentCategory);
            return this;
        }

        /**
         * The document's document_category(.proto).
         */
        public Builder documentCategory(Optional<String> documentCategory) {
            Utils.checkNotNull(documentCategory, "documentCategory");
            this.documentCategory = documentCategory;
            return this;
        }

        public Builder sourceDocument(Document sourceDocument) {
            Utils.checkNotNull(sourceDocument, "sourceDocument");
            this.sourceDocument = Optional.ofNullable(sourceDocument);
            return this;
        }

        public Builder sourceDocument(Optional<? extends Document> sourceDocument) {
            Utils.checkNotNull(sourceDocument, "sourceDocument");
            this.sourceDocument = sourceDocument;
            return this;
        }
        
        public Answer build() {
            return new Answer(
                id,
                docId,
                question,
                questionVariations,
                bodyText,
                boardId,
                audienceFilters,
                addedRoles,
                removedRoles,
                roles,
                sourceDocumentSpec,
                sourceType,
                permissions,
                combinedAnswerText,
                likes,
                author,
                createTime,
                updateTime,
                updatedBy,
                verification,
                board,
                collections,
                documentCategory,
                sourceDocument);
        }
    }
}
