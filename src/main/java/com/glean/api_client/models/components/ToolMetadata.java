/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.Objects;
import java.util.Optional;

/**
 * ToolMetadata
 * 
 * <p>The manifest for a tool that can be used to augment Glean Assistant.
 */
public class ToolMetadata {

    /**
     * The type of tool.
     */
    @JsonProperty("type")
    private ToolMetadataType type;

    /**
     * Unique identifier for the tool. Name should be understandable by the LLM, and will be used to invoke a tool.
     */
    @JsonProperty("name")
    private String name;

    /**
     * Human understandable name of the tool. Max 50 characters.
     */
    @JsonProperty("displayName")
    private String displayName;

    /**
     * An opaque id which is unique identifier for the tool.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("toolId")
    private Optional<String> toolId;

    /**
     * Description of the tool meant for a human.
     */
    @JsonProperty("displayDescription")
    private String displayDescription;

    /**
     * URL used to fetch the logo.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("logoUrl")
    private Optional<String> logoUrl;

    /**
     * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("objectName")
    private Optional<String> objectName;

    /**
     * Indicates the kind of knowledge a tool would access or modify.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("knowledgeType")
    private Optional<? extends KnowledgeType> knowledgeType;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdBy")
    private Optional<? extends PersonObject> createdBy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastUpdatedBy")
    private Optional<? extends PersonObject> lastUpdatedBy;

    /**
     * The time the tool was created in ISO format (ISO 8601)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<OffsetDateTime> createdAt;

    /**
     * The time the tool was last updated in ISO format (ISO 8601)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastUpdatedAt")
    private Optional<OffsetDateTime> lastUpdatedAt;

    /**
     * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("writeActionType")
    private Optional<? extends WriteActionType> writeActionType;

    /**
     * The type of authentication being used.
     * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
     * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
     * 'OAUTH_USER' uses individual user tokens for external API calls.
     * 'DWD' refers to domain wide delegation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authType")
    private Optional<? extends AuthType> authType;

    /**
     * Config for tool's authentication method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth")
    private Optional<? extends AuthConfig> auth;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("permissions")
    private Optional<? extends ObjectPermissions> permissions;

    /**
     * Usage instructions for the LLM to use this action.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("usageInstructions")
    private Optional<String> usageInstructions;

    /**
     * Whether this action has been fully configured and validated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isSetupFinished")
    private Optional<Boolean> isSetupFinished;

    @JsonCreator
    public ToolMetadata(
            @JsonProperty("type") ToolMetadataType type,
            @JsonProperty("name") String name,
            @JsonProperty("displayName") String displayName,
            @JsonProperty("toolId") Optional<String> toolId,
            @JsonProperty("displayDescription") String displayDescription,
            @JsonProperty("logoUrl") Optional<String> logoUrl,
            @JsonProperty("objectName") Optional<String> objectName,
            @JsonProperty("knowledgeType") Optional<? extends KnowledgeType> knowledgeType,
            @JsonProperty("createdBy") Optional<? extends PersonObject> createdBy,
            @JsonProperty("lastUpdatedBy") Optional<? extends PersonObject> lastUpdatedBy,
            @JsonProperty("createdAt") Optional<OffsetDateTime> createdAt,
            @JsonProperty("lastUpdatedAt") Optional<OffsetDateTime> lastUpdatedAt,
            @JsonProperty("writeActionType") Optional<? extends WriteActionType> writeActionType,
            @JsonProperty("authType") Optional<? extends AuthType> authType,
            @JsonProperty("auth") Optional<? extends AuthConfig> auth,
            @JsonProperty("permissions") Optional<? extends ObjectPermissions> permissions,
            @JsonProperty("usageInstructions") Optional<String> usageInstructions,
            @JsonProperty("isSetupFinished") Optional<Boolean> isSetupFinished) {
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(displayName, "displayName");
        Utils.checkNotNull(toolId, "toolId");
        Utils.checkNotNull(displayDescription, "displayDescription");
        Utils.checkNotNull(logoUrl, "logoUrl");
        Utils.checkNotNull(objectName, "objectName");
        Utils.checkNotNull(knowledgeType, "knowledgeType");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(lastUpdatedBy, "lastUpdatedBy");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(lastUpdatedAt, "lastUpdatedAt");
        Utils.checkNotNull(writeActionType, "writeActionType");
        Utils.checkNotNull(authType, "authType");
        Utils.checkNotNull(auth, "auth");
        Utils.checkNotNull(permissions, "permissions");
        Utils.checkNotNull(usageInstructions, "usageInstructions");
        Utils.checkNotNull(isSetupFinished, "isSetupFinished");
        this.type = type;
        this.name = name;
        this.displayName = displayName;
        this.toolId = toolId;
        this.displayDescription = displayDescription;
        this.logoUrl = logoUrl;
        this.objectName = objectName;
        this.knowledgeType = knowledgeType;
        this.createdBy = createdBy;
        this.lastUpdatedBy = lastUpdatedBy;
        this.createdAt = createdAt;
        this.lastUpdatedAt = lastUpdatedAt;
        this.writeActionType = writeActionType;
        this.authType = authType;
        this.auth = auth;
        this.permissions = permissions;
        this.usageInstructions = usageInstructions;
        this.isSetupFinished = isSetupFinished;
    }
    
    public ToolMetadata(
            ToolMetadataType type,
            String name,
            String displayName,
            String displayDescription) {
        this(type, name, displayName, Optional.empty(), displayDescription, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The type of tool.
     */
    @JsonIgnore
    public ToolMetadataType type() {
        return type;
    }

    /**
     * Unique identifier for the tool. Name should be understandable by the LLM, and will be used to invoke a tool.
     */
    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * Human understandable name of the tool. Max 50 characters.
     */
    @JsonIgnore
    public String displayName() {
        return displayName;
    }

    /**
     * An opaque id which is unique identifier for the tool.
     */
    @JsonIgnore
    public Optional<String> toolId() {
        return toolId;
    }

    /**
     * Description of the tool meant for a human.
     */
    @JsonIgnore
    public String displayDescription() {
        return displayDescription;
    }

    /**
     * URL used to fetch the logo.
     */
    @JsonIgnore
    public Optional<String> logoUrl() {
        return logoUrl;
    }

    /**
     * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
     */
    @JsonIgnore
    public Optional<String> objectName() {
        return objectName;
    }

    /**
     * Indicates the kind of knowledge a tool would access or modify.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<KnowledgeType> knowledgeType() {
        return (Optional<KnowledgeType>) knowledgeType;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PersonObject> createdBy() {
        return (Optional<PersonObject>) createdBy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PersonObject> lastUpdatedBy() {
        return (Optional<PersonObject>) lastUpdatedBy;
    }

    /**
     * The time the tool was created in ISO format (ISO 8601)
     */
    @JsonIgnore
    public Optional<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The time the tool was last updated in ISO format (ISO 8601)
     */
    @JsonIgnore
    public Optional<OffsetDateTime> lastUpdatedAt() {
        return lastUpdatedAt;
    }

    /**
     * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<WriteActionType> writeActionType() {
        return (Optional<WriteActionType>) writeActionType;
    }

    /**
     * The type of authentication being used.
     * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
     * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
     * 'OAUTH_USER' uses individual user tokens for external API calls.
     * 'DWD' refers to domain wide delegation.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AuthType> authType() {
        return (Optional<AuthType>) authType;
    }

    /**
     * Config for tool's authentication method.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AuthConfig> auth() {
        return (Optional<AuthConfig>) auth;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ObjectPermissions> permissions() {
        return (Optional<ObjectPermissions>) permissions;
    }

    /**
     * Usage instructions for the LLM to use this action.
     */
    @JsonIgnore
    public Optional<String> usageInstructions() {
        return usageInstructions;
    }

    /**
     * Whether this action has been fully configured and validated.
     */
    @JsonIgnore
    public Optional<Boolean> isSetupFinished() {
        return isSetupFinished;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The type of tool.
     */
    public ToolMetadata withType(ToolMetadataType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * Unique identifier for the tool. Name should be understandable by the LLM, and will be used to invoke a tool.
     */
    public ToolMetadata withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Human understandable name of the tool. Max 50 characters.
     */
    public ToolMetadata withDisplayName(String displayName) {
        Utils.checkNotNull(displayName, "displayName");
        this.displayName = displayName;
        return this;
    }

    /**
     * An opaque id which is unique identifier for the tool.
     */
    public ToolMetadata withToolId(String toolId) {
        Utils.checkNotNull(toolId, "toolId");
        this.toolId = Optional.ofNullable(toolId);
        return this;
    }

    /**
     * An opaque id which is unique identifier for the tool.
     */
    public ToolMetadata withToolId(Optional<String> toolId) {
        Utils.checkNotNull(toolId, "toolId");
        this.toolId = toolId;
        return this;
    }

    /**
     * Description of the tool meant for a human.
     */
    public ToolMetadata withDisplayDescription(String displayDescription) {
        Utils.checkNotNull(displayDescription, "displayDescription");
        this.displayDescription = displayDescription;
        return this;
    }

    /**
     * URL used to fetch the logo.
     */
    public ToolMetadata withLogoUrl(String logoUrl) {
        Utils.checkNotNull(logoUrl, "logoUrl");
        this.logoUrl = Optional.ofNullable(logoUrl);
        return this;
    }

    /**
     * URL used to fetch the logo.
     */
    public ToolMetadata withLogoUrl(Optional<String> logoUrl) {
        Utils.checkNotNull(logoUrl, "logoUrl");
        this.logoUrl = logoUrl;
        return this;
    }

    /**
     * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
     */
    public ToolMetadata withObjectName(String objectName) {
        Utils.checkNotNull(objectName, "objectName");
        this.objectName = Optional.ofNullable(objectName);
        return this;
    }

    /**
     * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
     */
    public ToolMetadata withObjectName(Optional<String> objectName) {
        Utils.checkNotNull(objectName, "objectName");
        this.objectName = objectName;
        return this;
    }

    /**
     * Indicates the kind of knowledge a tool would access or modify.
     */
    public ToolMetadata withKnowledgeType(KnowledgeType knowledgeType) {
        Utils.checkNotNull(knowledgeType, "knowledgeType");
        this.knowledgeType = Optional.ofNullable(knowledgeType);
        return this;
    }

    /**
     * Indicates the kind of knowledge a tool would access or modify.
     */
    public ToolMetadata withKnowledgeType(Optional<? extends KnowledgeType> knowledgeType) {
        Utils.checkNotNull(knowledgeType, "knowledgeType");
        this.knowledgeType = knowledgeType;
        return this;
    }

    public ToolMetadata withCreatedBy(PersonObject createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = Optional.ofNullable(createdBy);
        return this;
    }

    public ToolMetadata withCreatedBy(Optional<? extends PersonObject> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    public ToolMetadata withLastUpdatedBy(PersonObject lastUpdatedBy) {
        Utils.checkNotNull(lastUpdatedBy, "lastUpdatedBy");
        this.lastUpdatedBy = Optional.ofNullable(lastUpdatedBy);
        return this;
    }

    public ToolMetadata withLastUpdatedBy(Optional<? extends PersonObject> lastUpdatedBy) {
        Utils.checkNotNull(lastUpdatedBy, "lastUpdatedBy");
        this.lastUpdatedBy = lastUpdatedBy;
        return this;
    }

    /**
     * The time the tool was created in ISO format (ISO 8601)
     */
    public ToolMetadata withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * The time the tool was created in ISO format (ISO 8601)
     */
    public ToolMetadata withCreatedAt(Optional<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The time the tool was last updated in ISO format (ISO 8601)
     */
    public ToolMetadata withLastUpdatedAt(OffsetDateTime lastUpdatedAt) {
        Utils.checkNotNull(lastUpdatedAt, "lastUpdatedAt");
        this.lastUpdatedAt = Optional.ofNullable(lastUpdatedAt);
        return this;
    }

    /**
     * The time the tool was last updated in ISO format (ISO 8601)
     */
    public ToolMetadata withLastUpdatedAt(Optional<OffsetDateTime> lastUpdatedAt) {
        Utils.checkNotNull(lastUpdatedAt, "lastUpdatedAt");
        this.lastUpdatedAt = lastUpdatedAt;
        return this;
    }

    /**
     * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
     */
    public ToolMetadata withWriteActionType(WriteActionType writeActionType) {
        Utils.checkNotNull(writeActionType, "writeActionType");
        this.writeActionType = Optional.ofNullable(writeActionType);
        return this;
    }

    /**
     * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
     */
    public ToolMetadata withWriteActionType(Optional<? extends WriteActionType> writeActionType) {
        Utils.checkNotNull(writeActionType, "writeActionType");
        this.writeActionType = writeActionType;
        return this;
    }

    /**
     * The type of authentication being used.
     * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
     * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
     * 'OAUTH_USER' uses individual user tokens for external API calls.
     * 'DWD' refers to domain wide delegation.
     */
    public ToolMetadata withAuthType(AuthType authType) {
        Utils.checkNotNull(authType, "authType");
        this.authType = Optional.ofNullable(authType);
        return this;
    }

    /**
     * The type of authentication being used.
     * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
     * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
     * 'OAUTH_USER' uses individual user tokens for external API calls.
     * 'DWD' refers to domain wide delegation.
     */
    public ToolMetadata withAuthType(Optional<? extends AuthType> authType) {
        Utils.checkNotNull(authType, "authType");
        this.authType = authType;
        return this;
    }

    /**
     * Config for tool's authentication method.
     */
    public ToolMetadata withAuth(AuthConfig auth) {
        Utils.checkNotNull(auth, "auth");
        this.auth = Optional.ofNullable(auth);
        return this;
    }

    /**
     * Config for tool's authentication method.
     */
    public ToolMetadata withAuth(Optional<? extends AuthConfig> auth) {
        Utils.checkNotNull(auth, "auth");
        this.auth = auth;
        return this;
    }

    public ToolMetadata withPermissions(ObjectPermissions permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = Optional.ofNullable(permissions);
        return this;
    }

    public ToolMetadata withPermissions(Optional<? extends ObjectPermissions> permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = permissions;
        return this;
    }

    /**
     * Usage instructions for the LLM to use this action.
     */
    public ToolMetadata withUsageInstructions(String usageInstructions) {
        Utils.checkNotNull(usageInstructions, "usageInstructions");
        this.usageInstructions = Optional.ofNullable(usageInstructions);
        return this;
    }

    /**
     * Usage instructions for the LLM to use this action.
     */
    public ToolMetadata withUsageInstructions(Optional<String> usageInstructions) {
        Utils.checkNotNull(usageInstructions, "usageInstructions");
        this.usageInstructions = usageInstructions;
        return this;
    }

    /**
     * Whether this action has been fully configured and validated.
     */
    public ToolMetadata withIsSetupFinished(boolean isSetupFinished) {
        Utils.checkNotNull(isSetupFinished, "isSetupFinished");
        this.isSetupFinished = Optional.ofNullable(isSetupFinished);
        return this;
    }

    /**
     * Whether this action has been fully configured and validated.
     */
    public ToolMetadata withIsSetupFinished(Optional<Boolean> isSetupFinished) {
        Utils.checkNotNull(isSetupFinished, "isSetupFinished");
        this.isSetupFinished = isSetupFinished;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ToolMetadata other = (ToolMetadata) o;
        return 
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.displayName, other.displayName) &&
            Objects.deepEquals(this.toolId, other.toolId) &&
            Objects.deepEquals(this.displayDescription, other.displayDescription) &&
            Objects.deepEquals(this.logoUrl, other.logoUrl) &&
            Objects.deepEquals(this.objectName, other.objectName) &&
            Objects.deepEquals(this.knowledgeType, other.knowledgeType) &&
            Objects.deepEquals(this.createdBy, other.createdBy) &&
            Objects.deepEquals(this.lastUpdatedBy, other.lastUpdatedBy) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.lastUpdatedAt, other.lastUpdatedAt) &&
            Objects.deepEquals(this.writeActionType, other.writeActionType) &&
            Objects.deepEquals(this.authType, other.authType) &&
            Objects.deepEquals(this.auth, other.auth) &&
            Objects.deepEquals(this.permissions, other.permissions) &&
            Objects.deepEquals(this.usageInstructions, other.usageInstructions) &&
            Objects.deepEquals(this.isSetupFinished, other.isSetupFinished);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            type,
            name,
            displayName,
            toolId,
            displayDescription,
            logoUrl,
            objectName,
            knowledgeType,
            createdBy,
            lastUpdatedBy,
            createdAt,
            lastUpdatedAt,
            writeActionType,
            authType,
            auth,
            permissions,
            usageInstructions,
            isSetupFinished);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ToolMetadata.class,
                "type", type,
                "name", name,
                "displayName", displayName,
                "toolId", toolId,
                "displayDescription", displayDescription,
                "logoUrl", logoUrl,
                "objectName", objectName,
                "knowledgeType", knowledgeType,
                "createdBy", createdBy,
                "lastUpdatedBy", lastUpdatedBy,
                "createdAt", createdAt,
                "lastUpdatedAt", lastUpdatedAt,
                "writeActionType", writeActionType,
                "authType", authType,
                "auth", auth,
                "permissions", permissions,
                "usageInstructions", usageInstructions,
                "isSetupFinished", isSetupFinished);
    }
    
    public final static class Builder {
 
        private ToolMetadataType type;
 
        private String name;
 
        private String displayName;
 
        private Optional<String> toolId = Optional.empty();
 
        private String displayDescription;
 
        private Optional<String> logoUrl = Optional.empty();
 
        private Optional<String> objectName = Optional.empty();
 
        private Optional<? extends KnowledgeType> knowledgeType = Optional.empty();
 
        private Optional<? extends PersonObject> createdBy = Optional.empty();
 
        private Optional<? extends PersonObject> lastUpdatedBy = Optional.empty();
 
        private Optional<OffsetDateTime> createdAt = Optional.empty();
 
        private Optional<OffsetDateTime> lastUpdatedAt = Optional.empty();
 
        private Optional<? extends WriteActionType> writeActionType = Optional.empty();
 
        private Optional<? extends AuthType> authType = Optional.empty();
 
        private Optional<? extends AuthConfig> auth = Optional.empty();
 
        private Optional<? extends ObjectPermissions> permissions = Optional.empty();
 
        private Optional<String> usageInstructions = Optional.empty();
 
        private Optional<Boolean> isSetupFinished = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The type of tool.
         */
        public Builder type(ToolMetadataType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * Unique identifier for the tool. Name should be understandable by the LLM, and will be used to invoke a tool.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Human understandable name of the tool. Max 50 characters.
         */
        public Builder displayName(String displayName) {
            Utils.checkNotNull(displayName, "displayName");
            this.displayName = displayName;
            return this;
        }

        /**
         * An opaque id which is unique identifier for the tool.
         */
        public Builder toolId(String toolId) {
            Utils.checkNotNull(toolId, "toolId");
            this.toolId = Optional.ofNullable(toolId);
            return this;
        }

        /**
         * An opaque id which is unique identifier for the tool.
         */
        public Builder toolId(Optional<String> toolId) {
            Utils.checkNotNull(toolId, "toolId");
            this.toolId = toolId;
            return this;
        }

        /**
         * Description of the tool meant for a human.
         */
        public Builder displayDescription(String displayDescription) {
            Utils.checkNotNull(displayDescription, "displayDescription");
            this.displayDescription = displayDescription;
            return this;
        }

        /**
         * URL used to fetch the logo.
         */
        public Builder logoUrl(String logoUrl) {
            Utils.checkNotNull(logoUrl, "logoUrl");
            this.logoUrl = Optional.ofNullable(logoUrl);
            return this;
        }

        /**
         * URL used to fetch the logo.
         */
        public Builder logoUrl(Optional<String> logoUrl) {
            Utils.checkNotNull(logoUrl, "logoUrl");
            this.logoUrl = logoUrl;
            return this;
        }

        /**
         * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
         */
        public Builder objectName(String objectName) {
            Utils.checkNotNull(objectName, "objectName");
            this.objectName = Optional.ofNullable(objectName);
            return this;
        }

        /**
         * Name of the generated object. This will be used to indicate to the end user what the generated object contains.
         */
        public Builder objectName(Optional<String> objectName) {
            Utils.checkNotNull(objectName, "objectName");
            this.objectName = objectName;
            return this;
        }

        /**
         * Indicates the kind of knowledge a tool would access or modify.
         */
        public Builder knowledgeType(KnowledgeType knowledgeType) {
            Utils.checkNotNull(knowledgeType, "knowledgeType");
            this.knowledgeType = Optional.ofNullable(knowledgeType);
            return this;
        }

        /**
         * Indicates the kind of knowledge a tool would access or modify.
         */
        public Builder knowledgeType(Optional<? extends KnowledgeType> knowledgeType) {
            Utils.checkNotNull(knowledgeType, "knowledgeType");
            this.knowledgeType = knowledgeType;
            return this;
        }

        public Builder createdBy(PersonObject createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = Optional.ofNullable(createdBy);
            return this;
        }

        public Builder createdBy(Optional<? extends PersonObject> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }

        public Builder lastUpdatedBy(PersonObject lastUpdatedBy) {
            Utils.checkNotNull(lastUpdatedBy, "lastUpdatedBy");
            this.lastUpdatedBy = Optional.ofNullable(lastUpdatedBy);
            return this;
        }

        public Builder lastUpdatedBy(Optional<? extends PersonObject> lastUpdatedBy) {
            Utils.checkNotNull(lastUpdatedBy, "lastUpdatedBy");
            this.lastUpdatedBy = lastUpdatedBy;
            return this;
        }

        /**
         * The time the tool was created in ISO format (ISO 8601)
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The time the tool was created in ISO format (ISO 8601)
         */
        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The time the tool was last updated in ISO format (ISO 8601)
         */
        public Builder lastUpdatedAt(OffsetDateTime lastUpdatedAt) {
            Utils.checkNotNull(lastUpdatedAt, "lastUpdatedAt");
            this.lastUpdatedAt = Optional.ofNullable(lastUpdatedAt);
            return this;
        }

        /**
         * The time the tool was last updated in ISO format (ISO 8601)
         */
        public Builder lastUpdatedAt(Optional<OffsetDateTime> lastUpdatedAt) {
            Utils.checkNotNull(lastUpdatedAt, "lastUpdatedAt");
            this.lastUpdatedAt = lastUpdatedAt;
            return this;
        }

        /**
         * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
         */
        public Builder writeActionType(WriteActionType writeActionType) {
            Utils.checkNotNull(writeActionType, "writeActionType");
            this.writeActionType = Optional.ofNullable(writeActionType);
            return this;
        }

        /**
         * Valid only for write actions. Represents the type of write action. REDIRECT - The client renders the URL which contains information for carrying out the action. EXECUTION - Send a request to an external server and execute the action.
         */
        public Builder writeActionType(Optional<? extends WriteActionType> writeActionType) {
            Utils.checkNotNull(writeActionType, "writeActionType");
            this.writeActionType = writeActionType;
            return this;
        }

        /**
         * The type of authentication being used.
         * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
         * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
         * 'OAUTH_USER' uses individual user tokens for external API calls.
         * 'DWD' refers to domain wide delegation.
         */
        public Builder authType(AuthType authType) {
            Utils.checkNotNull(authType, "authType");
            this.authType = Optional.ofNullable(authType);
            return this;
        }

        /**
         * The type of authentication being used.
         * Use 'OAUTH_*' when Glean calls an external API (e.g., Jira) on behalf of a user to obtain an OAuth token.
         * 'OAUTH_ADMIN' utilizes an admin token for external API calls on behalf all users.
         * 'OAUTH_USER' uses individual user tokens for external API calls.
         * 'DWD' refers to domain wide delegation.
         */
        public Builder authType(Optional<? extends AuthType> authType) {
            Utils.checkNotNull(authType, "authType");
            this.authType = authType;
            return this;
        }

        /**
         * Config for tool's authentication method.
         */
        public Builder auth(AuthConfig auth) {
            Utils.checkNotNull(auth, "auth");
            this.auth = Optional.ofNullable(auth);
            return this;
        }

        /**
         * Config for tool's authentication method.
         */
        public Builder auth(Optional<? extends AuthConfig> auth) {
            Utils.checkNotNull(auth, "auth");
            this.auth = auth;
            return this;
        }

        public Builder permissions(ObjectPermissions permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = Optional.ofNullable(permissions);
            return this;
        }

        public Builder permissions(Optional<? extends ObjectPermissions> permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = permissions;
            return this;
        }

        /**
         * Usage instructions for the LLM to use this action.
         */
        public Builder usageInstructions(String usageInstructions) {
            Utils.checkNotNull(usageInstructions, "usageInstructions");
            this.usageInstructions = Optional.ofNullable(usageInstructions);
            return this;
        }

        /**
         * Usage instructions for the LLM to use this action.
         */
        public Builder usageInstructions(Optional<String> usageInstructions) {
            Utils.checkNotNull(usageInstructions, "usageInstructions");
            this.usageInstructions = usageInstructions;
            return this;
        }

        /**
         * Whether this action has been fully configured and validated.
         */
        public Builder isSetupFinished(boolean isSetupFinished) {
            Utils.checkNotNull(isSetupFinished, "isSetupFinished");
            this.isSetupFinished = Optional.ofNullable(isSetupFinished);
            return this;
        }

        /**
         * Whether this action has been fully configured and validated.
         */
        public Builder isSetupFinished(Optional<Boolean> isSetupFinished) {
            Utils.checkNotNull(isSetupFinished, "isSetupFinished");
            this.isSetupFinished = isSetupFinished;
            return this;
        }
        
        public ToolMetadata build() {
            return new ToolMetadata(
                type,
                name,
                displayName,
                toolId,
                displayDescription,
                logoUrl,
                objectName,
                knowledgeType,
                createdBy,
                lastUpdatedBy,
                createdAt,
                lastUpdatedAt,
                writeActionType,
                authType,
                auth,
                permissions,
                usageInstructions,
                isSetupFinished);
        }
    }
}
