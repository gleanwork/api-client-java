/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.utils.Utils;
import java.lang.Double;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

public class Customer {

    /**
     * Unique identifier.
     */
    @JsonProperty("id")
    private String id;

    /**
     * Link to company's associated website domains.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("domains")
    private Optional<? extends List<String>> domains;

    @JsonProperty("company")
    private Company company;

    /**
     * A map of {string, int} pairs representing counts of each document type associated with this customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("documentCounts")
    private Optional<? extends Map<String, Long>> documentCounts;

    /**
     * A list of POC for company.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("poc")
    private Optional<? extends List<Person>> poc;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends CustomerMetadata> metadata;

    /**
     * A list of Customers.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mergedCustomers")
    private Optional<? extends List<Customer>> mergedCustomers;

    /**
     * The date when the interaction with customer started.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("startDate")
    private Optional<LocalDate> startDate;

    /**
     * Average contract annual revenue with that customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contractAnnualRevenue")
    private Optional<Double> contractAnnualRevenue;

    /**
     * User facing (potentially generated) notes about company.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notes")
    private Optional<String> notes;

    @JsonCreator
    public Customer(
            @JsonProperty("id") String id,
            @JsonProperty("domains") Optional<? extends List<String>> domains,
            @JsonProperty("company") Company company,
            @JsonProperty("documentCounts") Optional<? extends Map<String, Long>> documentCounts,
            @JsonProperty("poc") Optional<? extends List<Person>> poc,
            @JsonProperty("metadata") Optional<? extends CustomerMetadata> metadata,
            @JsonProperty("mergedCustomers") Optional<? extends List<Customer>> mergedCustomers,
            @JsonProperty("startDate") Optional<LocalDate> startDate,
            @JsonProperty("contractAnnualRevenue") Optional<Double> contractAnnualRevenue,
            @JsonProperty("notes") Optional<String> notes) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(domains, "domains");
        Utils.checkNotNull(company, "company");
        Utils.checkNotNull(documentCounts, "documentCounts");
        Utils.checkNotNull(poc, "poc");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(mergedCustomers, "mergedCustomers");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(contractAnnualRevenue, "contractAnnualRevenue");
        Utils.checkNotNull(notes, "notes");
        this.id = id;
        this.domains = domains;
        this.company = company;
        this.documentCounts = documentCounts;
        this.poc = poc;
        this.metadata = metadata;
        this.mergedCustomers = mergedCustomers;
        this.startDate = startDate;
        this.contractAnnualRevenue = contractAnnualRevenue;
        this.notes = notes;
    }
    
    public Customer(
            String id,
            Company company) {
        this(id, Optional.empty(), company, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Unique identifier.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Link to company's associated website domains.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> domains() {
        return (Optional<List<String>>) domains;
    }

    @JsonIgnore
    public Company company() {
        return company;
    }

    /**
     * A map of {string, int} pairs representing counts of each document type associated with this customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, Long>> documentCounts() {
        return (Optional<Map<String, Long>>) documentCounts;
    }

    /**
     * A list of POC for company.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Person>> poc() {
        return (Optional<List<Person>>) poc;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CustomerMetadata> metadata() {
        return (Optional<CustomerMetadata>) metadata;
    }

    /**
     * A list of Customers.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Customer>> mergedCustomers() {
        return (Optional<List<Customer>>) mergedCustomers;
    }

    /**
     * The date when the interaction with customer started.
     */
    @JsonIgnore
    public Optional<LocalDate> startDate() {
        return startDate;
    }

    /**
     * Average contract annual revenue with that customer.
     */
    @JsonIgnore
    public Optional<Double> contractAnnualRevenue() {
        return contractAnnualRevenue;
    }

    /**
     * User facing (potentially generated) notes about company.
     */
    @JsonIgnore
    public Optional<String> notes() {
        return notes;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Unique identifier.
     */
    public Customer withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Link to company's associated website domains.
     */
    public Customer withDomains(List<String> domains) {
        Utils.checkNotNull(domains, "domains");
        this.domains = Optional.ofNullable(domains);
        return this;
    }

    /**
     * Link to company's associated website domains.
     */
    public Customer withDomains(Optional<? extends List<String>> domains) {
        Utils.checkNotNull(domains, "domains");
        this.domains = domains;
        return this;
    }

    public Customer withCompany(Company company) {
        Utils.checkNotNull(company, "company");
        this.company = company;
        return this;
    }

    /**
     * A map of {string, int} pairs representing counts of each document type associated with this customer.
     */
    public Customer withDocumentCounts(Map<String, Long> documentCounts) {
        Utils.checkNotNull(documentCounts, "documentCounts");
        this.documentCounts = Optional.ofNullable(documentCounts);
        return this;
    }

    /**
     * A map of {string, int} pairs representing counts of each document type associated with this customer.
     */
    public Customer withDocumentCounts(Optional<? extends Map<String, Long>> documentCounts) {
        Utils.checkNotNull(documentCounts, "documentCounts");
        this.documentCounts = documentCounts;
        return this;
    }

    /**
     * A list of POC for company.
     */
    public Customer withPoc(List<Person> poc) {
        Utils.checkNotNull(poc, "poc");
        this.poc = Optional.ofNullable(poc);
        return this;
    }

    /**
     * A list of POC for company.
     */
    public Customer withPoc(Optional<? extends List<Person>> poc) {
        Utils.checkNotNull(poc, "poc");
        this.poc = poc;
        return this;
    }

    public Customer withMetadata(CustomerMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public Customer withMetadata(Optional<? extends CustomerMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * A list of Customers.
     */
    public Customer withMergedCustomers(List<Customer> mergedCustomers) {
        Utils.checkNotNull(mergedCustomers, "mergedCustomers");
        this.mergedCustomers = Optional.ofNullable(mergedCustomers);
        return this;
    }

    /**
     * A list of Customers.
     */
    public Customer withMergedCustomers(Optional<? extends List<Customer>> mergedCustomers) {
        Utils.checkNotNull(mergedCustomers, "mergedCustomers");
        this.mergedCustomers = mergedCustomers;
        return this;
    }

    /**
     * The date when the interaction with customer started.
     */
    public Customer withStartDate(LocalDate startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * The date when the interaction with customer started.
     */
    public Customer withStartDate(Optional<LocalDate> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Average contract annual revenue with that customer.
     */
    public Customer withContractAnnualRevenue(double contractAnnualRevenue) {
        Utils.checkNotNull(contractAnnualRevenue, "contractAnnualRevenue");
        this.contractAnnualRevenue = Optional.ofNullable(contractAnnualRevenue);
        return this;
    }

    /**
     * Average contract annual revenue with that customer.
     */
    public Customer withContractAnnualRevenue(Optional<Double> contractAnnualRevenue) {
        Utils.checkNotNull(contractAnnualRevenue, "contractAnnualRevenue");
        this.contractAnnualRevenue = contractAnnualRevenue;
        return this;
    }

    /**
     * User facing (potentially generated) notes about company.
     */
    public Customer withNotes(String notes) {
        Utils.checkNotNull(notes, "notes");
        this.notes = Optional.ofNullable(notes);
        return this;
    }

    /**
     * User facing (potentially generated) notes about company.
     */
    public Customer withNotes(Optional<String> notes) {
        Utils.checkNotNull(notes, "notes");
        this.notes = notes;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Customer other = (Customer) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.domains, other.domains) &&
            Objects.deepEquals(this.company, other.company) &&
            Objects.deepEquals(this.documentCounts, other.documentCounts) &&
            Objects.deepEquals(this.poc, other.poc) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.mergedCustomers, other.mergedCustomers) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.contractAnnualRevenue, other.contractAnnualRevenue) &&
            Objects.deepEquals(this.notes, other.notes);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            domains,
            company,
            documentCounts,
            poc,
            metadata,
            mergedCustomers,
            startDate,
            contractAnnualRevenue,
            notes);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Customer.class,
                "id", id,
                "domains", domains,
                "company", company,
                "documentCounts", documentCounts,
                "poc", poc,
                "metadata", metadata,
                "mergedCustomers", mergedCustomers,
                "startDate", startDate,
                "contractAnnualRevenue", contractAnnualRevenue,
                "notes", notes);
    }
    
    public final static class Builder {
 
        private String id;
 
        private Optional<? extends List<String>> domains = Optional.empty();
 
        private Company company;
 
        private Optional<? extends Map<String, Long>> documentCounts = Optional.empty();
 
        private Optional<? extends List<Person>> poc = Optional.empty();
 
        private Optional<? extends CustomerMetadata> metadata = Optional.empty();
 
        private Optional<? extends List<Customer>> mergedCustomers = Optional.empty();
 
        private Optional<LocalDate> startDate = Optional.empty();
 
        private Optional<Double> contractAnnualRevenue = Optional.empty();
 
        private Optional<String> notes = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Unique identifier.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Link to company's associated website domains.
         */
        public Builder domains(List<String> domains) {
            Utils.checkNotNull(domains, "domains");
            this.domains = Optional.ofNullable(domains);
            return this;
        }

        /**
         * Link to company's associated website domains.
         */
        public Builder domains(Optional<? extends List<String>> domains) {
            Utils.checkNotNull(domains, "domains");
            this.domains = domains;
            return this;
        }

        public Builder company(Company company) {
            Utils.checkNotNull(company, "company");
            this.company = company;
            return this;
        }

        /**
         * A map of {string, int} pairs representing counts of each document type associated with this customer.
         */
        public Builder documentCounts(Map<String, Long> documentCounts) {
            Utils.checkNotNull(documentCounts, "documentCounts");
            this.documentCounts = Optional.ofNullable(documentCounts);
            return this;
        }

        /**
         * A map of {string, int} pairs representing counts of each document type associated with this customer.
         */
        public Builder documentCounts(Optional<? extends Map<String, Long>> documentCounts) {
            Utils.checkNotNull(documentCounts, "documentCounts");
            this.documentCounts = documentCounts;
            return this;
        }

        /**
         * A list of POC for company.
         */
        public Builder poc(List<Person> poc) {
            Utils.checkNotNull(poc, "poc");
            this.poc = Optional.ofNullable(poc);
            return this;
        }

        /**
         * A list of POC for company.
         */
        public Builder poc(Optional<? extends List<Person>> poc) {
            Utils.checkNotNull(poc, "poc");
            this.poc = poc;
            return this;
        }

        public Builder metadata(CustomerMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends CustomerMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * A list of Customers.
         */
        public Builder mergedCustomers(List<Customer> mergedCustomers) {
            Utils.checkNotNull(mergedCustomers, "mergedCustomers");
            this.mergedCustomers = Optional.ofNullable(mergedCustomers);
            return this;
        }

        /**
         * A list of Customers.
         */
        public Builder mergedCustomers(Optional<? extends List<Customer>> mergedCustomers) {
            Utils.checkNotNull(mergedCustomers, "mergedCustomers");
            this.mergedCustomers = mergedCustomers;
            return this;
        }

        /**
         * The date when the interaction with customer started.
         */
        public Builder startDate(LocalDate startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * The date when the interaction with customer started.
         */
        public Builder startDate(Optional<LocalDate> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Average contract annual revenue with that customer.
         */
        public Builder contractAnnualRevenue(double contractAnnualRevenue) {
            Utils.checkNotNull(contractAnnualRevenue, "contractAnnualRevenue");
            this.contractAnnualRevenue = Optional.ofNullable(contractAnnualRevenue);
            return this;
        }

        /**
         * Average contract annual revenue with that customer.
         */
        public Builder contractAnnualRevenue(Optional<Double> contractAnnualRevenue) {
            Utils.checkNotNull(contractAnnualRevenue, "contractAnnualRevenue");
            this.contractAnnualRevenue = contractAnnualRevenue;
            return this;
        }

        /**
         * User facing (potentially generated) notes about company.
         */
        public Builder notes(String notes) {
            Utils.checkNotNull(notes, "notes");
            this.notes = Optional.ofNullable(notes);
            return this;
        }

        /**
         * User facing (potentially generated) notes about company.
         */
        public Builder notes(Optional<String> notes) {
            Utils.checkNotNull(notes, "notes");
            this.notes = notes;
            return this;
        }
        
        public Customer build() {
            return new Customer(
                id,
                domains,
                company,
                documentCounts,
                poc,
                metadata,
                mergedCustomers,
                startDate,
                contractAnnualRevenue,
                notes);
        }
    }
}
