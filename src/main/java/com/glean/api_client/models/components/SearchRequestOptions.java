/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class SearchRequestOptions {

    /**
     * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasourceFilter")
    private Optional<String> datasourceFilter;

    /**
     * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasourcesFilter")
    private Optional<? extends List<String>> datasourcesFilter;

    /**
     * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queryOverridesFacetFilters")
    private Optional<Boolean> queryOverridesFacetFilters;

    /**
     * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("facetFilters")
    private Optional<? extends List<FacetFilter>> facetFilters;

    /**
     * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("facetFilterSets")
    private Optional<? extends List<FacetFilterSet>> facetFilterSets;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("facetBucketFilter")
    private Optional<? extends FacetBucketFilter> facetBucketFilter;

    /**
     * The maximum number of FacetBuckets to return in each FacetResult.
     */
    @JsonProperty("facetBucketSize")
    private long facetBucketSize;

    /**
     * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("defaultFacets")
    private Optional<? extends List<String>> defaultFacets;

    /**
     * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authTokens")
    private Optional<? extends List<AuthToken>> authTokens;

    /**
     * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fetchAllDatasourceCounts")
    private Optional<Boolean> fetchAllDatasourceCounts;

    /**
     * Array of hints containing which fields should be populated in the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("responseHints")
    private Optional<? extends List<ResponseHint>> responseHints;

    /**
     * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timezoneOffset")
    private Optional<Long> timezoneOffset;

    /**
     * Whether or not to disable spellcheck.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("disableSpellcheck")
    private Optional<Boolean> disableSpellcheck;

    /**
     * Disables automatic adjustment of the input query for spelling corrections or other reasons.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("disableQueryAutocorrect")
    private Optional<Boolean> disableQueryAutocorrect;

    /**
     * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("returnLlmContentOverSnippets")
    private Optional<Boolean> returnLlmContentOverSnippets;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("inclusions")
    private Optional<? extends RestrictionFilters> inclusions;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exclusions")
    private Optional<? extends RestrictionFilters> exclusions;

    @JsonCreator
    public SearchRequestOptions(
            @JsonProperty("datasourceFilter") Optional<String> datasourceFilter,
            @JsonProperty("datasourcesFilter") Optional<? extends List<String>> datasourcesFilter,
            @JsonProperty("queryOverridesFacetFilters") Optional<Boolean> queryOverridesFacetFilters,
            @JsonProperty("facetFilters") Optional<? extends List<FacetFilter>> facetFilters,
            @JsonProperty("facetFilterSets") Optional<? extends List<FacetFilterSet>> facetFilterSets,
            @JsonProperty("facetBucketFilter") Optional<? extends FacetBucketFilter> facetBucketFilter,
            @JsonProperty("facetBucketSize") long facetBucketSize,
            @JsonProperty("defaultFacets") Optional<? extends List<String>> defaultFacets,
            @JsonProperty("authTokens") Optional<? extends List<AuthToken>> authTokens,
            @JsonProperty("fetchAllDatasourceCounts") Optional<Boolean> fetchAllDatasourceCounts,
            @JsonProperty("responseHints") Optional<? extends List<ResponseHint>> responseHints,
            @JsonProperty("timezoneOffset") Optional<Long> timezoneOffset,
            @JsonProperty("disableSpellcheck") Optional<Boolean> disableSpellcheck,
            @JsonProperty("disableQueryAutocorrect") Optional<Boolean> disableQueryAutocorrect,
            @JsonProperty("returnLlmContentOverSnippets") Optional<Boolean> returnLlmContentOverSnippets,
            @JsonProperty("inclusions") Optional<? extends RestrictionFilters> inclusions,
            @JsonProperty("exclusions") Optional<? extends RestrictionFilters> exclusions) {
        Utils.checkNotNull(datasourceFilter, "datasourceFilter");
        Utils.checkNotNull(datasourcesFilter, "datasourcesFilter");
        Utils.checkNotNull(queryOverridesFacetFilters, "queryOverridesFacetFilters");
        Utils.checkNotNull(facetFilters, "facetFilters");
        Utils.checkNotNull(facetFilterSets, "facetFilterSets");
        Utils.checkNotNull(facetBucketFilter, "facetBucketFilter");
        Utils.checkNotNull(facetBucketSize, "facetBucketSize");
        Utils.checkNotNull(defaultFacets, "defaultFacets");
        Utils.checkNotNull(authTokens, "authTokens");
        Utils.checkNotNull(fetchAllDatasourceCounts, "fetchAllDatasourceCounts");
        Utils.checkNotNull(responseHints, "responseHints");
        Utils.checkNotNull(timezoneOffset, "timezoneOffset");
        Utils.checkNotNull(disableSpellcheck, "disableSpellcheck");
        Utils.checkNotNull(disableQueryAutocorrect, "disableQueryAutocorrect");
        Utils.checkNotNull(returnLlmContentOverSnippets, "returnLlmContentOverSnippets");
        Utils.checkNotNull(inclusions, "inclusions");
        Utils.checkNotNull(exclusions, "exclusions");
        this.datasourceFilter = datasourceFilter;
        this.datasourcesFilter = datasourcesFilter;
        this.queryOverridesFacetFilters = queryOverridesFacetFilters;
        this.facetFilters = facetFilters;
        this.facetFilterSets = facetFilterSets;
        this.facetBucketFilter = facetBucketFilter;
        this.facetBucketSize = facetBucketSize;
        this.defaultFacets = defaultFacets;
        this.authTokens = authTokens;
        this.fetchAllDatasourceCounts = fetchAllDatasourceCounts;
        this.responseHints = responseHints;
        this.timezoneOffset = timezoneOffset;
        this.disableSpellcheck = disableSpellcheck;
        this.disableQueryAutocorrect = disableQueryAutocorrect;
        this.returnLlmContentOverSnippets = returnLlmContentOverSnippets;
        this.inclusions = inclusions;
        this.exclusions = exclusions;
    }
    
    public SearchRequestOptions(
            long facetBucketSize) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), facetBucketSize, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
     */
    @JsonIgnore
    public Optional<String> datasourceFilter() {
        return datasourceFilter;
    }

    /**
     * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> datasourcesFilter() {
        return (Optional<List<String>>) datasourcesFilter;
    }

    /**
     * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
     */
    @JsonIgnore
    public Optional<Boolean> queryOverridesFacetFilters() {
        return queryOverridesFacetFilters;
    }

    /**
     * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FacetFilter>> facetFilters() {
        return (Optional<List<FacetFilter>>) facetFilters;
    }

    /**
     * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FacetFilterSet>> facetFilterSets() {
        return (Optional<List<FacetFilterSet>>) facetFilterSets;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<FacetBucketFilter> facetBucketFilter() {
        return (Optional<FacetBucketFilter>) facetBucketFilter;
    }

    /**
     * The maximum number of FacetBuckets to return in each FacetResult.
     */
    @JsonIgnore
    public long facetBucketSize() {
        return facetBucketSize;
    }

    /**
     * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> defaultFacets() {
        return (Optional<List<String>>) defaultFacets;
    }

    /**
     * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<AuthToken>> authTokens() {
        return (Optional<List<AuthToken>>) authTokens;
    }

    /**
     * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
     */
    @JsonIgnore
    public Optional<Boolean> fetchAllDatasourceCounts() {
        return fetchAllDatasourceCounts;
    }

    /**
     * Array of hints containing which fields should be populated in the response.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ResponseHint>> responseHints() {
        return (Optional<List<ResponseHint>>) responseHints;
    }

    /**
     * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
     */
    @JsonIgnore
    public Optional<Long> timezoneOffset() {
        return timezoneOffset;
    }

    /**
     * Whether or not to disable spellcheck.
     */
    @JsonIgnore
    public Optional<Boolean> disableSpellcheck() {
        return disableSpellcheck;
    }

    /**
     * Disables automatic adjustment of the input query for spelling corrections or other reasons.
     */
    @JsonIgnore
    public Optional<Boolean> disableQueryAutocorrect() {
        return disableQueryAutocorrect;
    }

    /**
     * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
     */
    @JsonIgnore
    public Optional<Boolean> returnLlmContentOverSnippets() {
        return returnLlmContentOverSnippets;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RestrictionFilters> inclusions() {
        return (Optional<RestrictionFilters>) inclusions;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RestrictionFilters> exclusions() {
        return (Optional<RestrictionFilters>) exclusions;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
     */
    public SearchRequestOptions withDatasourceFilter(String datasourceFilter) {
        Utils.checkNotNull(datasourceFilter, "datasourceFilter");
        this.datasourceFilter = Optional.ofNullable(datasourceFilter);
        return this;
    }

    /**
     * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
     */
    public SearchRequestOptions withDatasourceFilter(Optional<String> datasourceFilter) {
        Utils.checkNotNull(datasourceFilter, "datasourceFilter");
        this.datasourceFilter = datasourceFilter;
        return this;
    }

    /**
     * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
     */
    public SearchRequestOptions withDatasourcesFilter(List<String> datasourcesFilter) {
        Utils.checkNotNull(datasourcesFilter, "datasourcesFilter");
        this.datasourcesFilter = Optional.ofNullable(datasourcesFilter);
        return this;
    }

    /**
     * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
     */
    public SearchRequestOptions withDatasourcesFilter(Optional<? extends List<String>> datasourcesFilter) {
        Utils.checkNotNull(datasourcesFilter, "datasourcesFilter");
        this.datasourcesFilter = datasourcesFilter;
        return this;
    }

    /**
     * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
     */
    public SearchRequestOptions withQueryOverridesFacetFilters(boolean queryOverridesFacetFilters) {
        Utils.checkNotNull(queryOverridesFacetFilters, "queryOverridesFacetFilters");
        this.queryOverridesFacetFilters = Optional.ofNullable(queryOverridesFacetFilters);
        return this;
    }

    /**
     * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
     */
    public SearchRequestOptions withQueryOverridesFacetFilters(Optional<Boolean> queryOverridesFacetFilters) {
        Utils.checkNotNull(queryOverridesFacetFilters, "queryOverridesFacetFilters");
        this.queryOverridesFacetFilters = queryOverridesFacetFilters;
        return this;
    }

    /**
     * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
     */
    public SearchRequestOptions withFacetFilters(List<FacetFilter> facetFilters) {
        Utils.checkNotNull(facetFilters, "facetFilters");
        this.facetFilters = Optional.ofNullable(facetFilters);
        return this;
    }

    /**
     * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
     */
    public SearchRequestOptions withFacetFilters(Optional<? extends List<FacetFilter>> facetFilters) {
        Utils.checkNotNull(facetFilters, "facetFilters");
        this.facetFilters = facetFilters;
        return this;
    }

    /**
     * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
     */
    public SearchRequestOptions withFacetFilterSets(List<FacetFilterSet> facetFilterSets) {
        Utils.checkNotNull(facetFilterSets, "facetFilterSets");
        this.facetFilterSets = Optional.ofNullable(facetFilterSets);
        return this;
    }

    /**
     * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
     */
    public SearchRequestOptions withFacetFilterSets(Optional<? extends List<FacetFilterSet>> facetFilterSets) {
        Utils.checkNotNull(facetFilterSets, "facetFilterSets");
        this.facetFilterSets = facetFilterSets;
        return this;
    }

    public SearchRequestOptions withFacetBucketFilter(FacetBucketFilter facetBucketFilter) {
        Utils.checkNotNull(facetBucketFilter, "facetBucketFilter");
        this.facetBucketFilter = Optional.ofNullable(facetBucketFilter);
        return this;
    }

    public SearchRequestOptions withFacetBucketFilter(Optional<? extends FacetBucketFilter> facetBucketFilter) {
        Utils.checkNotNull(facetBucketFilter, "facetBucketFilter");
        this.facetBucketFilter = facetBucketFilter;
        return this;
    }

    /**
     * The maximum number of FacetBuckets to return in each FacetResult.
     */
    public SearchRequestOptions withFacetBucketSize(long facetBucketSize) {
        Utils.checkNotNull(facetBucketSize, "facetBucketSize");
        this.facetBucketSize = facetBucketSize;
        return this;
    }

    /**
     * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
     */
    public SearchRequestOptions withDefaultFacets(List<String> defaultFacets) {
        Utils.checkNotNull(defaultFacets, "defaultFacets");
        this.defaultFacets = Optional.ofNullable(defaultFacets);
        return this;
    }

    /**
     * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
     */
    public SearchRequestOptions withDefaultFacets(Optional<? extends List<String>> defaultFacets) {
        Utils.checkNotNull(defaultFacets, "defaultFacets");
        this.defaultFacets = defaultFacets;
        return this;
    }

    /**
     * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
     */
    public SearchRequestOptions withAuthTokens(List<AuthToken> authTokens) {
        Utils.checkNotNull(authTokens, "authTokens");
        this.authTokens = Optional.ofNullable(authTokens);
        return this;
    }

    /**
     * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
     */
    public SearchRequestOptions withAuthTokens(Optional<? extends List<AuthToken>> authTokens) {
        Utils.checkNotNull(authTokens, "authTokens");
        this.authTokens = authTokens;
        return this;
    }

    /**
     * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
     */
    public SearchRequestOptions withFetchAllDatasourceCounts(boolean fetchAllDatasourceCounts) {
        Utils.checkNotNull(fetchAllDatasourceCounts, "fetchAllDatasourceCounts");
        this.fetchAllDatasourceCounts = Optional.ofNullable(fetchAllDatasourceCounts);
        return this;
    }

    /**
     * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
     */
    public SearchRequestOptions withFetchAllDatasourceCounts(Optional<Boolean> fetchAllDatasourceCounts) {
        Utils.checkNotNull(fetchAllDatasourceCounts, "fetchAllDatasourceCounts");
        this.fetchAllDatasourceCounts = fetchAllDatasourceCounts;
        return this;
    }

    /**
     * Array of hints containing which fields should be populated in the response.
     */
    public SearchRequestOptions withResponseHints(List<ResponseHint> responseHints) {
        Utils.checkNotNull(responseHints, "responseHints");
        this.responseHints = Optional.ofNullable(responseHints);
        return this;
    }

    /**
     * Array of hints containing which fields should be populated in the response.
     */
    public SearchRequestOptions withResponseHints(Optional<? extends List<ResponseHint>> responseHints) {
        Utils.checkNotNull(responseHints, "responseHints");
        this.responseHints = responseHints;
        return this;
    }

    /**
     * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
     */
    public SearchRequestOptions withTimezoneOffset(long timezoneOffset) {
        Utils.checkNotNull(timezoneOffset, "timezoneOffset");
        this.timezoneOffset = Optional.ofNullable(timezoneOffset);
        return this;
    }

    /**
     * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
     */
    public SearchRequestOptions withTimezoneOffset(Optional<Long> timezoneOffset) {
        Utils.checkNotNull(timezoneOffset, "timezoneOffset");
        this.timezoneOffset = timezoneOffset;
        return this;
    }

    /**
     * Whether or not to disable spellcheck.
     */
    public SearchRequestOptions withDisableSpellcheck(boolean disableSpellcheck) {
        Utils.checkNotNull(disableSpellcheck, "disableSpellcheck");
        this.disableSpellcheck = Optional.ofNullable(disableSpellcheck);
        return this;
    }

    /**
     * Whether or not to disable spellcheck.
     */
    public SearchRequestOptions withDisableSpellcheck(Optional<Boolean> disableSpellcheck) {
        Utils.checkNotNull(disableSpellcheck, "disableSpellcheck");
        this.disableSpellcheck = disableSpellcheck;
        return this;
    }

    /**
     * Disables automatic adjustment of the input query for spelling corrections or other reasons.
     */
    public SearchRequestOptions withDisableQueryAutocorrect(boolean disableQueryAutocorrect) {
        Utils.checkNotNull(disableQueryAutocorrect, "disableQueryAutocorrect");
        this.disableQueryAutocorrect = Optional.ofNullable(disableQueryAutocorrect);
        return this;
    }

    /**
     * Disables automatic adjustment of the input query for spelling corrections or other reasons.
     */
    public SearchRequestOptions withDisableQueryAutocorrect(Optional<Boolean> disableQueryAutocorrect) {
        Utils.checkNotNull(disableQueryAutocorrect, "disableQueryAutocorrect");
        this.disableQueryAutocorrect = disableQueryAutocorrect;
        return this;
    }

    /**
     * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
     */
    public SearchRequestOptions withReturnLlmContentOverSnippets(boolean returnLlmContentOverSnippets) {
        Utils.checkNotNull(returnLlmContentOverSnippets, "returnLlmContentOverSnippets");
        this.returnLlmContentOverSnippets = Optional.ofNullable(returnLlmContentOverSnippets);
        return this;
    }

    /**
     * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
     */
    public SearchRequestOptions withReturnLlmContentOverSnippets(Optional<Boolean> returnLlmContentOverSnippets) {
        Utils.checkNotNull(returnLlmContentOverSnippets, "returnLlmContentOverSnippets");
        this.returnLlmContentOverSnippets = returnLlmContentOverSnippets;
        return this;
    }

    public SearchRequestOptions withInclusions(RestrictionFilters inclusions) {
        Utils.checkNotNull(inclusions, "inclusions");
        this.inclusions = Optional.ofNullable(inclusions);
        return this;
    }

    public SearchRequestOptions withInclusions(Optional<? extends RestrictionFilters> inclusions) {
        Utils.checkNotNull(inclusions, "inclusions");
        this.inclusions = inclusions;
        return this;
    }

    public SearchRequestOptions withExclusions(RestrictionFilters exclusions) {
        Utils.checkNotNull(exclusions, "exclusions");
        this.exclusions = Optional.ofNullable(exclusions);
        return this;
    }

    public SearchRequestOptions withExclusions(Optional<? extends RestrictionFilters> exclusions) {
        Utils.checkNotNull(exclusions, "exclusions");
        this.exclusions = exclusions;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SearchRequestOptions other = (SearchRequestOptions) o;
        return 
            Objects.deepEquals(this.datasourceFilter, other.datasourceFilter) &&
            Objects.deepEquals(this.datasourcesFilter, other.datasourcesFilter) &&
            Objects.deepEquals(this.queryOverridesFacetFilters, other.queryOverridesFacetFilters) &&
            Objects.deepEquals(this.facetFilters, other.facetFilters) &&
            Objects.deepEquals(this.facetFilterSets, other.facetFilterSets) &&
            Objects.deepEquals(this.facetBucketFilter, other.facetBucketFilter) &&
            Objects.deepEquals(this.facetBucketSize, other.facetBucketSize) &&
            Objects.deepEquals(this.defaultFacets, other.defaultFacets) &&
            Objects.deepEquals(this.authTokens, other.authTokens) &&
            Objects.deepEquals(this.fetchAllDatasourceCounts, other.fetchAllDatasourceCounts) &&
            Objects.deepEquals(this.responseHints, other.responseHints) &&
            Objects.deepEquals(this.timezoneOffset, other.timezoneOffset) &&
            Objects.deepEquals(this.disableSpellcheck, other.disableSpellcheck) &&
            Objects.deepEquals(this.disableQueryAutocorrect, other.disableQueryAutocorrect) &&
            Objects.deepEquals(this.returnLlmContentOverSnippets, other.returnLlmContentOverSnippets) &&
            Objects.deepEquals(this.inclusions, other.inclusions) &&
            Objects.deepEquals(this.exclusions, other.exclusions);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            datasourceFilter,
            datasourcesFilter,
            queryOverridesFacetFilters,
            facetFilters,
            facetFilterSets,
            facetBucketFilter,
            facetBucketSize,
            defaultFacets,
            authTokens,
            fetchAllDatasourceCounts,
            responseHints,
            timezoneOffset,
            disableSpellcheck,
            disableQueryAutocorrect,
            returnLlmContentOverSnippets,
            inclusions,
            exclusions);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SearchRequestOptions.class,
                "datasourceFilter", datasourceFilter,
                "datasourcesFilter", datasourcesFilter,
                "queryOverridesFacetFilters", queryOverridesFacetFilters,
                "facetFilters", facetFilters,
                "facetFilterSets", facetFilterSets,
                "facetBucketFilter", facetBucketFilter,
                "facetBucketSize", facetBucketSize,
                "defaultFacets", defaultFacets,
                "authTokens", authTokens,
                "fetchAllDatasourceCounts", fetchAllDatasourceCounts,
                "responseHints", responseHints,
                "timezoneOffset", timezoneOffset,
                "disableSpellcheck", disableSpellcheck,
                "disableQueryAutocorrect", disableQueryAutocorrect,
                "returnLlmContentOverSnippets", returnLlmContentOverSnippets,
                "inclusions", inclusions,
                "exclusions", exclusions);
    }
    
    public final static class Builder {
 
        private Optional<String> datasourceFilter = Optional.empty();
 
        private Optional<? extends List<String>> datasourcesFilter = Optional.empty();
 
        private Optional<Boolean> queryOverridesFacetFilters = Optional.empty();
 
        private Optional<? extends List<FacetFilter>> facetFilters = Optional.empty();
 
        private Optional<? extends List<FacetFilterSet>> facetFilterSets = Optional.empty();
 
        private Optional<? extends FacetBucketFilter> facetBucketFilter = Optional.empty();
 
        private Long facetBucketSize;
 
        private Optional<? extends List<String>> defaultFacets = Optional.empty();
 
        private Optional<? extends List<AuthToken>> authTokens = Optional.empty();
 
        private Optional<Boolean> fetchAllDatasourceCounts = Optional.empty();
 
        private Optional<? extends List<ResponseHint>> responseHints = Optional.empty();
 
        private Optional<Long> timezoneOffset = Optional.empty();
 
        private Optional<Boolean> disableSpellcheck = Optional.empty();
 
        private Optional<Boolean> disableQueryAutocorrect = Optional.empty();
 
        private Optional<Boolean> returnLlmContentOverSnippets = Optional.empty();
 
        private Optional<? extends RestrictionFilters> inclusions = Optional.empty();
 
        private Optional<? extends RestrictionFilters> exclusions = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
         */
        public Builder datasourceFilter(String datasourceFilter) {
            Utils.checkNotNull(datasourceFilter, "datasourceFilter");
            this.datasourceFilter = Optional.ofNullable(datasourceFilter);
            return this;
        }

        /**
         * Filter results to a single datasource name (e.g. gmail, slack). All results are returned if missing.
         */
        public Builder datasourceFilter(Optional<String> datasourceFilter) {
            Utils.checkNotNull(datasourceFilter, "datasourceFilter");
            this.datasourceFilter = datasourceFilter;
            return this;
        }

        /**
         * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
         */
        public Builder datasourcesFilter(List<String> datasourcesFilter) {
            Utils.checkNotNull(datasourcesFilter, "datasourcesFilter");
            this.datasourcesFilter = Optional.ofNullable(datasourcesFilter);
            return this;
        }

        /**
         * Filter results to one or more datasources (e.g. gmail, slack). All results are returned if missing.
         */
        public Builder datasourcesFilter(Optional<? extends List<String>> datasourcesFilter) {
            Utils.checkNotNull(datasourcesFilter, "datasourcesFilter");
            this.datasourcesFilter = datasourcesFilter;
            return this;
        }

        /**
         * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
         */
        public Builder queryOverridesFacetFilters(boolean queryOverridesFacetFilters) {
            Utils.checkNotNull(queryOverridesFacetFilters, "queryOverridesFacetFilters");
            this.queryOverridesFacetFilters = Optional.ofNullable(queryOverridesFacetFilters);
            return this;
        }

        /**
         * If true, the operators in the query are taken to override any operators in facetFilters in the case of conflict. This is used to correctly set rewrittenFacetFilters and rewrittenQuery.
         */
        public Builder queryOverridesFacetFilters(Optional<Boolean> queryOverridesFacetFilters) {
            Utils.checkNotNull(queryOverridesFacetFilters, "queryOverridesFacetFilters");
            this.queryOverridesFacetFilters = queryOverridesFacetFilters;
            return this;
        }

        /**
         * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
         */
        public Builder facetFilters(List<FacetFilter> facetFilters) {
            Utils.checkNotNull(facetFilters, "facetFilters");
            this.facetFilters = Optional.ofNullable(facetFilters);
            return this;
        }

        /**
         * A list of filters for the query. An AND is assumed between different facetFilters. For example, owner Sumeet and type Spreadsheet shows documents that are by Sumeet AND are Spreadsheets.
         */
        public Builder facetFilters(Optional<? extends List<FacetFilter>> facetFilters) {
            Utils.checkNotNull(facetFilters, "facetFilters");
            this.facetFilters = facetFilters;
            return this;
        }

        /**
         * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
         */
        public Builder facetFilterSets(List<FacetFilterSet> facetFilterSets) {
            Utils.checkNotNull(facetFilterSets, "facetFilterSets");
            this.facetFilterSets = Optional.ofNullable(facetFilterSets);
            return this;
        }

        /**
         * A list of facet filter sets that will be OR'ed together. SearchRequestOptions where both facetFilterSets and facetFilters set are considered as bad request. Callers should set only one of these fields.
         */
        public Builder facetFilterSets(Optional<? extends List<FacetFilterSet>> facetFilterSets) {
            Utils.checkNotNull(facetFilterSets, "facetFilterSets");
            this.facetFilterSets = facetFilterSets;
            return this;
        }

        public Builder facetBucketFilter(FacetBucketFilter facetBucketFilter) {
            Utils.checkNotNull(facetBucketFilter, "facetBucketFilter");
            this.facetBucketFilter = Optional.ofNullable(facetBucketFilter);
            return this;
        }

        public Builder facetBucketFilter(Optional<? extends FacetBucketFilter> facetBucketFilter) {
            Utils.checkNotNull(facetBucketFilter, "facetBucketFilter");
            this.facetBucketFilter = facetBucketFilter;
            return this;
        }

        /**
         * The maximum number of FacetBuckets to return in each FacetResult.
         */
        public Builder facetBucketSize(long facetBucketSize) {
            Utils.checkNotNull(facetBucketSize, "facetBucketSize");
            this.facetBucketSize = facetBucketSize;
            return this;
        }

        /**
         * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
         */
        public Builder defaultFacets(List<String> defaultFacets) {
            Utils.checkNotNull(defaultFacets, "defaultFacets");
            this.defaultFacets = Optional.ofNullable(defaultFacets);
            return this;
        }

        /**
         * Facets for which FacetResults should be fetched and that don't apply to a particular datasource. If specified, these values will replace the standard default facets (last_updated_at, from, etc.). The requested facets will be returned alongside datasource-specific facets if searching a single datasource.
         */
        public Builder defaultFacets(Optional<? extends List<String>> defaultFacets) {
            Utils.checkNotNull(defaultFacets, "defaultFacets");
            this.defaultFacets = defaultFacets;
            return this;
        }

        /**
         * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
         */
        public Builder authTokens(List<AuthToken> authTokens) {
            Utils.checkNotNull(authTokens, "authTokens");
            this.authTokens = Optional.ofNullable(authTokens);
            return this;
        }

        /**
         * Auth tokens which may be used for non-indexed, federated results (e.g. Gmail).
         */
        public Builder authTokens(Optional<? extends List<AuthToken>> authTokens) {
            Utils.checkNotNull(authTokens, "authTokens");
            this.authTokens = authTokens;
            return this;
        }

        /**
         * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
         */
        public Builder fetchAllDatasourceCounts(boolean fetchAllDatasourceCounts) {
            Utils.checkNotNull(fetchAllDatasourceCounts, "fetchAllDatasourceCounts");
            this.fetchAllDatasourceCounts = Optional.ofNullable(fetchAllDatasourceCounts);
            return this;
        }

        /**
         * Hints that the QE should return result counts (via the datasource facet result) for all supported datasources, rather than just those specified in the datasource[s]Filter
         */
        public Builder fetchAllDatasourceCounts(Optional<Boolean> fetchAllDatasourceCounts) {
            Utils.checkNotNull(fetchAllDatasourceCounts, "fetchAllDatasourceCounts");
            this.fetchAllDatasourceCounts = fetchAllDatasourceCounts;
            return this;
        }

        /**
         * Array of hints containing which fields should be populated in the response.
         */
        public Builder responseHints(List<ResponseHint> responseHints) {
            Utils.checkNotNull(responseHints, "responseHints");
            this.responseHints = Optional.ofNullable(responseHints);
            return this;
        }

        /**
         * Array of hints containing which fields should be populated in the response.
         */
        public Builder responseHints(Optional<? extends List<ResponseHint>> responseHints) {
            Utils.checkNotNull(responseHints, "responseHints");
            this.responseHints = responseHints;
            return this;
        }

        /**
         * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
         */
        public Builder timezoneOffset(long timezoneOffset) {
            Utils.checkNotNull(timezoneOffset, "timezoneOffset");
            this.timezoneOffset = Optional.ofNullable(timezoneOffset);
            return this;
        }

        /**
         * The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
         */
        public Builder timezoneOffset(Optional<Long> timezoneOffset) {
            Utils.checkNotNull(timezoneOffset, "timezoneOffset");
            this.timezoneOffset = timezoneOffset;
            return this;
        }

        /**
         * Whether or not to disable spellcheck.
         */
        public Builder disableSpellcheck(boolean disableSpellcheck) {
            Utils.checkNotNull(disableSpellcheck, "disableSpellcheck");
            this.disableSpellcheck = Optional.ofNullable(disableSpellcheck);
            return this;
        }

        /**
         * Whether or not to disable spellcheck.
         */
        public Builder disableSpellcheck(Optional<Boolean> disableSpellcheck) {
            Utils.checkNotNull(disableSpellcheck, "disableSpellcheck");
            this.disableSpellcheck = disableSpellcheck;
            return this;
        }

        /**
         * Disables automatic adjustment of the input query for spelling corrections or other reasons.
         */
        public Builder disableQueryAutocorrect(boolean disableQueryAutocorrect) {
            Utils.checkNotNull(disableQueryAutocorrect, "disableQueryAutocorrect");
            this.disableQueryAutocorrect = Optional.ofNullable(disableQueryAutocorrect);
            return this;
        }

        /**
         * Disables automatic adjustment of the input query for spelling corrections or other reasons.
         */
        public Builder disableQueryAutocorrect(Optional<Boolean> disableQueryAutocorrect) {
            Utils.checkNotNull(disableQueryAutocorrect, "disableQueryAutocorrect");
            this.disableQueryAutocorrect = disableQueryAutocorrect;
            return this;
        }

        /**
         * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
         */
        public Builder returnLlmContentOverSnippets(boolean returnLlmContentOverSnippets) {
            Utils.checkNotNull(returnLlmContentOverSnippets, "returnLlmContentOverSnippets");
            this.returnLlmContentOverSnippets = Optional.ofNullable(returnLlmContentOverSnippets);
            return this;
        }

        /**
         * [beta] Enables expanded content to be returned for LLM usage. The size of content per result returned should be modified using maxSnippetSize. Server may return less or more than what is specified in maxSnippetSize. For more details, https://docs.google.com/document/d/1CTOLSxWWT9WDEnHVLoCUaxbGYyXYP8kctPRF-RluSQY/edit. Requires sufficient permissions.
         */
        public Builder returnLlmContentOverSnippets(Optional<Boolean> returnLlmContentOverSnippets) {
            Utils.checkNotNull(returnLlmContentOverSnippets, "returnLlmContentOverSnippets");
            this.returnLlmContentOverSnippets = returnLlmContentOverSnippets;
            return this;
        }

        public Builder inclusions(RestrictionFilters inclusions) {
            Utils.checkNotNull(inclusions, "inclusions");
            this.inclusions = Optional.ofNullable(inclusions);
            return this;
        }

        public Builder inclusions(Optional<? extends RestrictionFilters> inclusions) {
            Utils.checkNotNull(inclusions, "inclusions");
            this.inclusions = inclusions;
            return this;
        }

        public Builder exclusions(RestrictionFilters exclusions) {
            Utils.checkNotNull(exclusions, "exclusions");
            this.exclusions = Optional.ofNullable(exclusions);
            return this;
        }

        public Builder exclusions(Optional<? extends RestrictionFilters> exclusions) {
            Utils.checkNotNull(exclusions, "exclusions");
            this.exclusions = exclusions;
            return this;
        }
        
        public SearchRequestOptions build() {
            return new SearchRequestOptions(
                datasourceFilter,
                datasourcesFilter,
                queryOverridesFacetFilters,
                facetFilters,
                facetFilterSets,
                facetBucketFilter,
                facetBucketSize,
                defaultFacets,
                authTokens,
                fetchAllDatasourceCounts,
                responseHints,
                timezoneOffset,
                disableSpellcheck,
                disableQueryAutocorrect,
                returnLlmContentOverSnippets,
                inclusions,
                exclusions);
        }
    }
}
