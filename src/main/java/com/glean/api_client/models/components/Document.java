/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class Document {

    /**
     * The Glean Document ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The app or other repository type from which the document was extracted
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("datasource")
    private Optional<String> datasource;

    /**
     * The source from which document content was pulled, e.g. an API crawl or browser history
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("connectorType")
    private Optional<? extends ConnectorType> connectorType;

    /**
     * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("docType")
    private Optional<String> docType;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("content")
    private Optional<? extends DocumentContent> content;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("containerDocument")
    private Optional<? extends Document> containerDocument;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentDocument")
    private Optional<? extends Document> parentDocument;

    /**
     * The title of the document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;

    /**
     * A permalink for the document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("url")
    private Optional<String> url;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends DocumentMetadata> metadata;

    /**
     * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sections")
    private Optional<? extends List<DocumentSection>> sections;

    @JsonCreator
    public Document(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("datasource") Optional<String> datasource,
            @JsonProperty("connectorType") Optional<? extends ConnectorType> connectorType,
            @JsonProperty("docType") Optional<String> docType,
            @JsonProperty("content") Optional<? extends DocumentContent> content,
            @JsonProperty("containerDocument") Optional<? extends Document> containerDocument,
            @JsonProperty("parentDocument") Optional<? extends Document> parentDocument,
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("url") Optional<String> url,
            @JsonProperty("metadata") Optional<? extends DocumentMetadata> metadata,
            @JsonProperty("sections") Optional<? extends List<DocumentSection>> sections) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(datasource, "datasource");
        Utils.checkNotNull(connectorType, "connectorType");
        Utils.checkNotNull(docType, "docType");
        Utils.checkNotNull(content, "content");
        Utils.checkNotNull(containerDocument, "containerDocument");
        Utils.checkNotNull(parentDocument, "parentDocument");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(url, "url");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(sections, "sections");
        this.id = id;
        this.datasource = datasource;
        this.connectorType = connectorType;
        this.docType = docType;
        this.content = content;
        this.containerDocument = containerDocument;
        this.parentDocument = parentDocument;
        this.title = title;
        this.url = url;
        this.metadata = metadata;
        this.sections = sections;
    }
    
    public Document() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The Glean Document ID.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The app or other repository type from which the document was extracted
     */
    @JsonIgnore
    public Optional<String> datasource() {
        return datasource;
    }

    /**
     * The source from which document content was pulled, e.g. an API crawl or browser history
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ConnectorType> connectorType() {
        return (Optional<ConnectorType>) connectorType;
    }

    /**
     * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    @JsonIgnore
    public Optional<String> docType() {
        return docType;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DocumentContent> content() {
        return (Optional<DocumentContent>) content;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Document> containerDocument() {
        return (Optional<Document>) containerDocument;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Document> parentDocument() {
        return (Optional<Document>) parentDocument;
    }

    /**
     * The title of the document.
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    /**
     * A permalink for the document.
     */
    @JsonIgnore
    public Optional<String> url() {
        return url;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DocumentMetadata> metadata() {
        return (Optional<DocumentMetadata>) metadata;
    }

    /**
     * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<DocumentSection>> sections() {
        return (Optional<List<DocumentSection>>) sections;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The Glean Document ID.
     */
    public Document withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The Glean Document ID.
     */
    public Document withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The app or other repository type from which the document was extracted
     */
    public Document withDatasource(String datasource) {
        Utils.checkNotNull(datasource, "datasource");
        this.datasource = Optional.ofNullable(datasource);
        return this;
    }

    /**
     * The app or other repository type from which the document was extracted
     */
    public Document withDatasource(Optional<String> datasource) {
        Utils.checkNotNull(datasource, "datasource");
        this.datasource = datasource;
        return this;
    }

    /**
     * The source from which document content was pulled, e.g. an API crawl or browser history
     */
    public Document withConnectorType(ConnectorType connectorType) {
        Utils.checkNotNull(connectorType, "connectorType");
        this.connectorType = Optional.ofNullable(connectorType);
        return this;
    }

    /**
     * The source from which document content was pulled, e.g. an API crawl or browser history
     */
    public Document withConnectorType(Optional<? extends ConnectorType> connectorType) {
        Utils.checkNotNull(connectorType, "connectorType");
        this.connectorType = connectorType;
        return this;
    }

    /**
     * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    public Document withDocType(String docType) {
        Utils.checkNotNull(docType, "docType");
        this.docType = Optional.ofNullable(docType);
        return this;
    }

    /**
     * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
     */
    public Document withDocType(Optional<String> docType) {
        Utils.checkNotNull(docType, "docType");
        this.docType = docType;
        return this;
    }

    public Document withContent(DocumentContent content) {
        Utils.checkNotNull(content, "content");
        this.content = Optional.ofNullable(content);
        return this;
    }

    public Document withContent(Optional<? extends DocumentContent> content) {
        Utils.checkNotNull(content, "content");
        this.content = content;
        return this;
    }

    public Document withContainerDocument(Document containerDocument) {
        Utils.checkNotNull(containerDocument, "containerDocument");
        this.containerDocument = Optional.ofNullable(containerDocument);
        return this;
    }

    public Document withContainerDocument(Optional<? extends Document> containerDocument) {
        Utils.checkNotNull(containerDocument, "containerDocument");
        this.containerDocument = containerDocument;
        return this;
    }

    public Document withParentDocument(Document parentDocument) {
        Utils.checkNotNull(parentDocument, "parentDocument");
        this.parentDocument = Optional.ofNullable(parentDocument);
        return this;
    }

    public Document withParentDocument(Optional<? extends Document> parentDocument) {
        Utils.checkNotNull(parentDocument, "parentDocument");
        this.parentDocument = parentDocument;
        return this;
    }

    /**
     * The title of the document.
     */
    public Document withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }

    /**
     * The title of the document.
     */
    public Document withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * A permalink for the document.
     */
    public Document withUrl(String url) {
        Utils.checkNotNull(url, "url");
        this.url = Optional.ofNullable(url);
        return this;
    }

    /**
     * A permalink for the document.
     */
    public Document withUrl(Optional<String> url) {
        Utils.checkNotNull(url, "url");
        this.url = url;
        return this;
    }

    public Document withMetadata(DocumentMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public Document withMetadata(Optional<? extends DocumentMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
     */
    public Document withSections(List<DocumentSection> sections) {
        Utils.checkNotNull(sections, "sections");
        this.sections = Optional.ofNullable(sections);
        return this;
    }

    /**
     * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
     */
    public Document withSections(Optional<? extends List<DocumentSection>> sections) {
        Utils.checkNotNull(sections, "sections");
        this.sections = sections;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Document other = (Document) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.datasource, other.datasource) &&
            Objects.deepEquals(this.connectorType, other.connectorType) &&
            Objects.deepEquals(this.docType, other.docType) &&
            Objects.deepEquals(this.content, other.content) &&
            Objects.deepEquals(this.containerDocument, other.containerDocument) &&
            Objects.deepEquals(this.parentDocument, other.parentDocument) &&
            Objects.deepEquals(this.title, other.title) &&
            Objects.deepEquals(this.url, other.url) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.sections, other.sections);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            datasource,
            connectorType,
            docType,
            content,
            containerDocument,
            parentDocument,
            title,
            url,
            metadata,
            sections);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Document.class,
                "id", id,
                "datasource", datasource,
                "connectorType", connectorType,
                "docType", docType,
                "content", content,
                "containerDocument", containerDocument,
                "parentDocument", parentDocument,
                "title", title,
                "url", url,
                "metadata", metadata,
                "sections", sections);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> datasource = Optional.empty();
 
        private Optional<? extends ConnectorType> connectorType = Optional.empty();
 
        private Optional<String> docType = Optional.empty();
 
        private Optional<? extends DocumentContent> content = Optional.empty();
 
        private Optional<? extends Document> containerDocument = Optional.empty();
 
        private Optional<? extends Document> parentDocument = Optional.empty();
 
        private Optional<String> title = Optional.empty();
 
        private Optional<String> url = Optional.empty();
 
        private Optional<? extends DocumentMetadata> metadata = Optional.empty();
 
        private Optional<? extends List<DocumentSection>> sections = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The Glean Document ID.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The Glean Document ID.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * The app or other repository type from which the document was extracted
         */
        public Builder datasource(String datasource) {
            Utils.checkNotNull(datasource, "datasource");
            this.datasource = Optional.ofNullable(datasource);
            return this;
        }

        /**
         * The app or other repository type from which the document was extracted
         */
        public Builder datasource(Optional<String> datasource) {
            Utils.checkNotNull(datasource, "datasource");
            this.datasource = datasource;
            return this;
        }

        /**
         * The source from which document content was pulled, e.g. an API crawl or browser history
         */
        public Builder connectorType(ConnectorType connectorType) {
            Utils.checkNotNull(connectorType, "connectorType");
            this.connectorType = Optional.ofNullable(connectorType);
            return this;
        }

        /**
         * The source from which document content was pulled, e.g. an API crawl or browser history
         */
        public Builder connectorType(Optional<? extends ConnectorType> connectorType) {
            Utils.checkNotNull(connectorType, "connectorType");
            this.connectorType = connectorType;
            return this;
        }

        /**
         * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
         */
        public Builder docType(String docType) {
            Utils.checkNotNull(docType, "docType");
            this.docType = Optional.ofNullable(docType);
            return this;
        }

        /**
         * The datasource-specific type of the document (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
         */
        public Builder docType(Optional<String> docType) {
            Utils.checkNotNull(docType, "docType");
            this.docType = docType;
            return this;
        }

        public Builder content(DocumentContent content) {
            Utils.checkNotNull(content, "content");
            this.content = Optional.ofNullable(content);
            return this;
        }

        public Builder content(Optional<? extends DocumentContent> content) {
            Utils.checkNotNull(content, "content");
            this.content = content;
            return this;
        }

        public Builder containerDocument(Document containerDocument) {
            Utils.checkNotNull(containerDocument, "containerDocument");
            this.containerDocument = Optional.ofNullable(containerDocument);
            return this;
        }

        public Builder containerDocument(Optional<? extends Document> containerDocument) {
            Utils.checkNotNull(containerDocument, "containerDocument");
            this.containerDocument = containerDocument;
            return this;
        }

        public Builder parentDocument(Document parentDocument) {
            Utils.checkNotNull(parentDocument, "parentDocument");
            this.parentDocument = Optional.ofNullable(parentDocument);
            return this;
        }

        public Builder parentDocument(Optional<? extends Document> parentDocument) {
            Utils.checkNotNull(parentDocument, "parentDocument");
            this.parentDocument = parentDocument;
            return this;
        }

        /**
         * The title of the document.
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * The title of the document.
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }

        /**
         * A permalink for the document.
         */
        public Builder url(String url) {
            Utils.checkNotNull(url, "url");
            this.url = Optional.ofNullable(url);
            return this;
        }

        /**
         * A permalink for the document.
         */
        public Builder url(Optional<String> url) {
            Utils.checkNotNull(url, "url");
            this.url = url;
            return this;
        }

        public Builder metadata(DocumentMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends DocumentMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
         */
        public Builder sections(List<DocumentSection> sections) {
            Utils.checkNotNull(sections, "sections");
            this.sections = Optional.ofNullable(sections);
            return this;
        }

        /**
         * A list of content sub-sections in the document, e.g. text blocks with different headings in a Drive doc or Confluence page.
         */
        public Builder sections(Optional<? extends List<DocumentSection>> sections) {
            Utils.checkNotNull(sections, "sections");
            this.sections = sections;
            return this;
        }
        
        public Document build() {
            return new Document(
                id,
                datasource,
                connectorType,
                docType,
                content,
                containerDocument,
                parentDocument,
                title,
                url,
                metadata,
                sections);
        }
    }
}
