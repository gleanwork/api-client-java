/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.glean.api_client.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.glean.api_client.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * DocumentPermissionsDefinition
 * 
 * <p>describes the access control details of the document
 */
public class DocumentPermissionsDefinition {

    /**
     * List of users who can view the document
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowedUsers")
    private Optional<? extends List<UserReferenceDefinition>> allowedUsers;

    /**
     * List of groups that can view the document
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowedGroups")
    private Optional<? extends List<String>> allowedGroups;

    /**
     * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowedGroupIntersections")
    private Optional<? extends List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections;

    /**
     * If true, then any Glean user can view the document
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowAnonymousAccess")
    private Optional<Boolean> allowAnonymousAccess;

    /**
     * If true, then any user who has an account in the datasource can view the document.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowAllDatasourceUsersAccess")
    private Optional<Boolean> allowAllDatasourceUsersAccess;

    @JsonCreator
    public DocumentPermissionsDefinition(
            @JsonProperty("allowedUsers") Optional<? extends List<UserReferenceDefinition>> allowedUsers,
            @JsonProperty("allowedGroups") Optional<? extends List<String>> allowedGroups,
            @JsonProperty("allowedGroupIntersections") Optional<? extends List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections,
            @JsonProperty("allowAnonymousAccess") Optional<Boolean> allowAnonymousAccess,
            @JsonProperty("allowAllDatasourceUsersAccess") Optional<Boolean> allowAllDatasourceUsersAccess) {
        Utils.checkNotNull(allowedUsers, "allowedUsers");
        Utils.checkNotNull(allowedGroups, "allowedGroups");
        Utils.checkNotNull(allowedGroupIntersections, "allowedGroupIntersections");
        Utils.checkNotNull(allowAnonymousAccess, "allowAnonymousAccess");
        Utils.checkNotNull(allowAllDatasourceUsersAccess, "allowAllDatasourceUsersAccess");
        this.allowedUsers = allowedUsers;
        this.allowedGroups = allowedGroups;
        this.allowedGroupIntersections = allowedGroupIntersections;
        this.allowAnonymousAccess = allowAnonymousAccess;
        this.allowAllDatasourceUsersAccess = allowAllDatasourceUsersAccess;
    }
    
    public DocumentPermissionsDefinition() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * List of users who can view the document
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<UserReferenceDefinition>> allowedUsers() {
        return (Optional<List<UserReferenceDefinition>>) allowedUsers;
    }

    /**
     * List of groups that can view the document
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> allowedGroups() {
        return (Optional<List<String>>) allowedGroups;
    }

    /**
     * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections() {
        return (Optional<List<PermissionsGroupIntersectionDefinition>>) allowedGroupIntersections;
    }

    /**
     * If true, then any Glean user can view the document
     */
    @JsonIgnore
    public Optional<Boolean> allowAnonymousAccess() {
        return allowAnonymousAccess;
    }

    /**
     * If true, then any user who has an account in the datasource can view the document.
     */
    @JsonIgnore
    public Optional<Boolean> allowAllDatasourceUsersAccess() {
        return allowAllDatasourceUsersAccess;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * List of users who can view the document
     */
    public DocumentPermissionsDefinition withAllowedUsers(List<UserReferenceDefinition> allowedUsers) {
        Utils.checkNotNull(allowedUsers, "allowedUsers");
        this.allowedUsers = Optional.ofNullable(allowedUsers);
        return this;
    }

    /**
     * List of users who can view the document
     */
    public DocumentPermissionsDefinition withAllowedUsers(Optional<? extends List<UserReferenceDefinition>> allowedUsers) {
        Utils.checkNotNull(allowedUsers, "allowedUsers");
        this.allowedUsers = allowedUsers;
        return this;
    }

    /**
     * List of groups that can view the document
     */
    public DocumentPermissionsDefinition withAllowedGroups(List<String> allowedGroups) {
        Utils.checkNotNull(allowedGroups, "allowedGroups");
        this.allowedGroups = Optional.ofNullable(allowedGroups);
        return this;
    }

    /**
     * List of groups that can view the document
     */
    public DocumentPermissionsDefinition withAllowedGroups(Optional<? extends List<String>> allowedGroups) {
        Utils.checkNotNull(allowedGroups, "allowedGroups");
        this.allowedGroups = allowedGroups;
        return this;
    }

    /**
     * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
     */
    public DocumentPermissionsDefinition withAllowedGroupIntersections(List<PermissionsGroupIntersectionDefinition> allowedGroupIntersections) {
        Utils.checkNotNull(allowedGroupIntersections, "allowedGroupIntersections");
        this.allowedGroupIntersections = Optional.ofNullable(allowedGroupIntersections);
        return this;
    }

    /**
     * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
     */
    public DocumentPermissionsDefinition withAllowedGroupIntersections(Optional<? extends List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections) {
        Utils.checkNotNull(allowedGroupIntersections, "allowedGroupIntersections");
        this.allowedGroupIntersections = allowedGroupIntersections;
        return this;
    }

    /**
     * If true, then any Glean user can view the document
     */
    public DocumentPermissionsDefinition withAllowAnonymousAccess(boolean allowAnonymousAccess) {
        Utils.checkNotNull(allowAnonymousAccess, "allowAnonymousAccess");
        this.allowAnonymousAccess = Optional.ofNullable(allowAnonymousAccess);
        return this;
    }

    /**
     * If true, then any Glean user can view the document
     */
    public DocumentPermissionsDefinition withAllowAnonymousAccess(Optional<Boolean> allowAnonymousAccess) {
        Utils.checkNotNull(allowAnonymousAccess, "allowAnonymousAccess");
        this.allowAnonymousAccess = allowAnonymousAccess;
        return this;
    }

    /**
     * If true, then any user who has an account in the datasource can view the document.
     */
    public DocumentPermissionsDefinition withAllowAllDatasourceUsersAccess(boolean allowAllDatasourceUsersAccess) {
        Utils.checkNotNull(allowAllDatasourceUsersAccess, "allowAllDatasourceUsersAccess");
        this.allowAllDatasourceUsersAccess = Optional.ofNullable(allowAllDatasourceUsersAccess);
        return this;
    }

    /**
     * If true, then any user who has an account in the datasource can view the document.
     */
    public DocumentPermissionsDefinition withAllowAllDatasourceUsersAccess(Optional<Boolean> allowAllDatasourceUsersAccess) {
        Utils.checkNotNull(allowAllDatasourceUsersAccess, "allowAllDatasourceUsersAccess");
        this.allowAllDatasourceUsersAccess = allowAllDatasourceUsersAccess;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DocumentPermissionsDefinition other = (DocumentPermissionsDefinition) o;
        return 
            Objects.deepEquals(this.allowedUsers, other.allowedUsers) &&
            Objects.deepEquals(this.allowedGroups, other.allowedGroups) &&
            Objects.deepEquals(this.allowedGroupIntersections, other.allowedGroupIntersections) &&
            Objects.deepEquals(this.allowAnonymousAccess, other.allowAnonymousAccess) &&
            Objects.deepEquals(this.allowAllDatasourceUsersAccess, other.allowAllDatasourceUsersAccess);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            allowedUsers,
            allowedGroups,
            allowedGroupIntersections,
            allowAnonymousAccess,
            allowAllDatasourceUsersAccess);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DocumentPermissionsDefinition.class,
                "allowedUsers", allowedUsers,
                "allowedGroups", allowedGroups,
                "allowedGroupIntersections", allowedGroupIntersections,
                "allowAnonymousAccess", allowAnonymousAccess,
                "allowAllDatasourceUsersAccess", allowAllDatasourceUsersAccess);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<UserReferenceDefinition>> allowedUsers = Optional.empty();
 
        private Optional<? extends List<String>> allowedGroups = Optional.empty();
 
        private Optional<? extends List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections = Optional.empty();
 
        private Optional<Boolean> allowAnonymousAccess = Optional.empty();
 
        private Optional<Boolean> allowAllDatasourceUsersAccess = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * List of users who can view the document
         */
        public Builder allowedUsers(List<UserReferenceDefinition> allowedUsers) {
            Utils.checkNotNull(allowedUsers, "allowedUsers");
            this.allowedUsers = Optional.ofNullable(allowedUsers);
            return this;
        }

        /**
         * List of users who can view the document
         */
        public Builder allowedUsers(Optional<? extends List<UserReferenceDefinition>> allowedUsers) {
            Utils.checkNotNull(allowedUsers, "allowedUsers");
            this.allowedUsers = allowedUsers;
            return this;
        }

        /**
         * List of groups that can view the document
         */
        public Builder allowedGroups(List<String> allowedGroups) {
            Utils.checkNotNull(allowedGroups, "allowedGroups");
            this.allowedGroups = Optional.ofNullable(allowedGroups);
            return this;
        }

        /**
         * List of groups that can view the document
         */
        public Builder allowedGroups(Optional<? extends List<String>> allowedGroups) {
            Utils.checkNotNull(allowedGroups, "allowedGroups");
            this.allowedGroups = allowedGroups;
            return this;
        }

        /**
         * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
         */
        public Builder allowedGroupIntersections(List<PermissionsGroupIntersectionDefinition> allowedGroupIntersections) {
            Utils.checkNotNull(allowedGroupIntersections, "allowedGroupIntersections");
            this.allowedGroupIntersections = Optional.ofNullable(allowedGroupIntersections);
            return this;
        }

        /**
         * List of allowed group intersections. This describes a permissions constraint of the form ((GroupA AND GroupB AND GroupC) OR (GroupX AND GroupY) OR ...
         */
        public Builder allowedGroupIntersections(Optional<? extends List<PermissionsGroupIntersectionDefinition>> allowedGroupIntersections) {
            Utils.checkNotNull(allowedGroupIntersections, "allowedGroupIntersections");
            this.allowedGroupIntersections = allowedGroupIntersections;
            return this;
        }

        /**
         * If true, then any Glean user can view the document
         */
        public Builder allowAnonymousAccess(boolean allowAnonymousAccess) {
            Utils.checkNotNull(allowAnonymousAccess, "allowAnonymousAccess");
            this.allowAnonymousAccess = Optional.ofNullable(allowAnonymousAccess);
            return this;
        }

        /**
         * If true, then any Glean user can view the document
         */
        public Builder allowAnonymousAccess(Optional<Boolean> allowAnonymousAccess) {
            Utils.checkNotNull(allowAnonymousAccess, "allowAnonymousAccess");
            this.allowAnonymousAccess = allowAnonymousAccess;
            return this;
        }

        /**
         * If true, then any user who has an account in the datasource can view the document.
         */
        public Builder allowAllDatasourceUsersAccess(boolean allowAllDatasourceUsersAccess) {
            Utils.checkNotNull(allowAllDatasourceUsersAccess, "allowAllDatasourceUsersAccess");
            this.allowAllDatasourceUsersAccess = Optional.ofNullable(allowAllDatasourceUsersAccess);
            return this;
        }

        /**
         * If true, then any user who has an account in the datasource can view the document.
         */
        public Builder allowAllDatasourceUsersAccess(Optional<Boolean> allowAllDatasourceUsersAccess) {
            Utils.checkNotNull(allowAllDatasourceUsersAccess, "allowAllDatasourceUsersAccess");
            this.allowAllDatasourceUsersAccess = allowAllDatasourceUsersAccess;
            return this;
        }
        
        public DocumentPermissionsDefinition build() {
            return new DocumentPermissionsDefinition(
                allowedUsers,
                allowedGroups,
                allowedGroupIntersections,
                allowAnonymousAccess,
                allowAllDatasourceUsersAccess);
        }
    }
}
